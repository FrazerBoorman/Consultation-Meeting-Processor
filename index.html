<!doctype html><html lang="en"><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Consultation Meeting Processor</title>
  <meta name="color-scheme" content="light dark">
  <!-- Google OAuth client ID (same as other tools) -->
  <meta name="google-oauth-client-id" content="105230737516-l8tlnck4idde83pjetrotobpt8borvts.apps.googleusercontent.com">
  <!-- SheetJS for Excel reading/writing – primary CDN -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
  <!-- Google Identity Services -->
  <script src="https://accounts.google.com/gsi/client" async="" defer=""></script>

  <style>
    :root {
      --bg:#0f172a; --card:#020617; --panel:#020617; --border:#1e293b;
      --text:#e5e7eb; --muted:#94a3b8; --accent:#38bdf8; --accent-soft:rgba(56,189,248,0.12);
      --danger:#ef4444;
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg:#f8fafc; --card:#ffffff; --panel:#ffffff; --border:#e5e7eb;
        --text:#020617; --muted:#475569; --accent:#0ea5e9; --accent-soft:rgba(14,165,233,0.10);
        --danger:#b91c1c;
      }
    }
    * { box-sizing:border-box; }
    html, body { height:100%; }
    body {
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:
        radial-gradient(900px 600px at 5% 0%, rgba(56,189,248,0.10), transparent 55%),
        radial-gradient(800px 600px at 95% 0%, rgba(129,140,248,0.12), transparent 50%),
        var(--bg);
      color:var(--text);
    }
    .wrap {
      max-width: 1200px;
      margin:0 auto;
      padding:18px;
    }
    .card {
      background:var(--card);
      border-radius:20px;
      border:1px solid var(--border);
      padding:18px 18px 22px;
      box-shadow:0 18px 40px rgba(15,23,42,0.45);
      margin-bottom:16px;
    }
    h1 {
      margin:0 0 4px;
      font-size:26px;
      letter-spacing:.02em;
      display:flex;
      align-items:baseline;
      gap:8px;
      flex-wrap:wrap;
    }
    .version {
      font-size:11px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted);
    }
    .muted { color:var(--muted); font-size:14px; }
    .pill {
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size:11px;
      padding:3px 9px;
      border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted);
      text-decoration:none;
      cursor:pointer;
    }
    .pill:hover {
      border-color:var(--accent);
      color:var(--accent);
      background:var(--accent-soft);
    }
    .section {
      margin-top:14px;
      padding:12px;
      border-radius:12px;
      background:rgba(15,23,42,0.65);
      border:1px dashed var(--border);
    }
    @media (prefers-color-scheme: light) {
      .section { background:#f9fafb; }
    }
    .section-title {
      font-size:13px;
      font-weight:700;
      text-transform:uppercase;
      letter-spacing:.08em;
      color:var(--muted);
      margin-bottom:6px;
    }
    label {
      font-size:13px;
      font-weight:600;
      margin-bottom:4px;
      display:block;
    }
    input, select, textarea {
      width:100%;
      font-size:14px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
    }
    textarea { resize:vertical; min-height:70px; }
    input::placeholder, textarea::placeholder { color:var(--muted); }
    .small-note { font-size:11px;color:var(--muted);margin-top:3px; }

    .grid {
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap:10px;
    }

    .btn-row { display:flex;flex-wrap:wrap;gap:8px;margin-top:8px; }
    button {
      border-radius:999px;
      border:1px solid var(--border);
      padding:8px 13px;
      font-size:14px;
      display:inline-flex;
      align-items:center;
      gap:6px;
      background:var(--panel);
      color:var(--text);
      cursor:pointer;
      transition:transform .06s ease, box-shadow .12s ease, background .12s ease, border-color .12s ease;
    }
    button.primary {
      border-color:var(--accent);
      background:linear-gradient(180deg,var(--accent-soft),transparent);
    }
    button:hover {
      transform:translateY(-1px);
      box-shadow:0 4px 12px rgba(15,23,42,0.5);
    }

    #status, #aiStatus {
      font-size:12px;color:var(--muted);margin-top:4px;
    }
    .danger { color:var(--danger); }

    details.transcript summary {
      cursor:pointer;
      font-size:13px;
      color:var(--muted);
      margin-bottom:4px;
    }
    .transcript-body {
      max-height:260px;
      overflow:auto;
      font-size:13px;
      line-height:1.5;
      border-radius:10px;
      border:1px solid var(--border);
      padding:8px;
      background:var(--panel);
      white-space:pre-wrap;
    }

    .summary-box {
      padding:8px;
      border-radius:10px;
      border:1px solid var(--border);
      background:var(--panel);
      font-size:13px;
      line-height:1.5;
      max-height:260px;
      overflow:auto;
    }
    .summary-box h2 {
      font-size:13px;
      margin:0 0 4px;
      text-transform:uppercase;
      letter-spacing:.06em;
      color:var(--muted);
    }
    ul { margin:4px 0 6px 18px;padding:0;font-size:13px; }
    li { margin-bottom:2px; }

    table {
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }
    th, td {
      border:1px solid var(--border);
      padding:4px 6px;
      vertical-align:top;
    }
    th {
      background:rgba(15,23,42,0.6);
      font-weight:600;
    }
    @media (prefers-color-scheme: light) {
      th { background:#e5e7eb; }
    }

    #productsTableWrapper, #proposalPreview {
      max-height:280px;
      overflow:auto;
      border-radius:10px;
      border:1px solid var(--border);
      padding:8px;
      background:var(--panel);
      font-size:13px;
      white-space:pre-wrap;
    }

    details.debug {
      margin-top:10px;
      border-radius:12px;
      border:1px dashed var(--border);
      padding:8px 10px;
      background:rgba(15,23,42,0.4);
      font-size:11px;
    }
    @media (prefers-color-scheme: light) {
      details.debug { background:#f3f4f6; }
    }
    details.debug summary {
      cursor:pointer;
      font-size:12px;
      color:var(--muted);
    }
    details.debug pre {
      white-space:pre-wrap;
      font-size:11px;
      margin-top:4px;
    }

    details.api {
      margin-top:10px;
      border-radius:12px;
      border:1px dashed var(--border);
      padding:6px 10px 10px;
      background:rgba(15,23,42,0.4);
      font-size:11px;
    }
    @media (prefers-color-scheme: light) {
      details.api { background:#f3f4f6; }
    }
    details.api summary {
      cursor:pointer;
      font-size:12px;
      color:var(--muted);
    }
  </style>
<style id="googleidentityservice_button_styles">.qJTHM{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;color:#202124;direction:ltr;-webkit-touch-callout:none;font-family:"Roboto-Regular",arial,sans-serif;-webkit-font-smoothing:antialiased;font-weight:400;margin:0;overflow:hidden;-webkit-text-size-adjust:100%}.ynRLnc{left:-9999px;position:absolute;top:-9999px}.L6cTce{display:none}.bltWBb{overflow-wrap:break-word;word-break:break-word}.hSRGPd{color:#1a73e8;cursor:pointer;font-weight:500;text-decoration:none}.Bz112c-W3lGp{height:16px;width:16px}.Bz112c-E3DyYd{height:20px;width:20px}.Bz112c-r9oPif{height:24px;width:24px}.Bz112c-u2z5K{height:36px;width:36px}.Bz112c-uaxL4e{border-radius:10px}.LgbsSe-Bz112c{display:block}.S9gUrf-YoZ4jf{border:none;margin:0;padding:0}.S9gUrf-YoZ4jf *{border:none;margin:0;padding:0}.fFW7wc-ibnC6b>.aZ2wEe>div{border-color:#4285f4}.P1ekSe-ZMv3u{-webkit-transition:height linear .2s;transition:height linear .2s}.P1ekSe-ZMv3u>div:nth-child(1){background-color:#1a73e8!important;-webkit-transition:width linear .3s;transition:width linear .3s}.P1ekSe-ZMv3u>div:nth-child(2){background-image:-webkit-gradient(linear,left top,right top,from(rgba(255,255,255,.7)),to(rgba(255,255,255,.7))),-webkit-gradient(linear,left top,right top,from(#1a73e8),to(#1a73e8))!important;background-image:-webkit-linear-gradient(left,rgba(255,255,255,.7),rgba(255,255,255,.7)),-webkit-linear-gradient(left,#1a73e8,#1a73e8)!important;background-image:linear-gradient(to right,rgba(255,255,255,.7),rgba(255,255,255,.7)),linear-gradient(to right,#1a73e8,#1a73e8)!important}.P1ekSe-ZMv3u>div:nth-child(3){background-image:-webkit-gradient(linear,left top,right top,from(rgba(255,255,255,.7)),to(rgba(255,255,255,.7))),-webkit-gradient(linear,left top,right top,from(#1a73e8),to(#1a73e8))!important;background-image:-webkit-linear-gradient(left,rgba(255,255,255,.7),rgba(255,255,255,.7)),-webkit-linear-gradient(left,#1a73e8,#1a73e8)!important;background-image:linear-gradient(to right,rgba(255,255,255,.7),rgba(255,255,255,.7)),linear-gradient(to right,#1a73e8,#1a73e8)!important}.haAclf{display:inline-block}.nsm7Bb-HzV7m-LgbsSe{border-radius:4px;box-sizing:border-box;-webkit-transition:background-color .218s,border-color .218s;transition:background-color .218s,border-color .218s;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;-webkit-appearance:none;background-color:#fff;background-image:none;border:1px solid #dadce0;color:#3c4043;cursor:pointer;font-family:"Google Sans",arial,sans-serif;font-size:14px;height:40px;letter-spacing:.25px;outline:none;overflow:hidden;padding:0 12px;position:relative;text-align:center;vertical-align:middle;white-space:nowrap;width:auto}@media screen and (-ms-high-contrast:active){.nsm7Bb-HzV7m-LgbsSe{border:2px solid windowText;color:windowText}}@media screen and (preferes-contrast:more){.nsm7Bb-HzV7m-LgbsSe{color:#000}}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe{font-size:14px;height:32px;letter-spacing:.25px;padding:0 10px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe{font-size:11px;height:20px;letter-spacing:.3px;padding:0 8px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe{padding:0;width:40px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.pSzOP-SxQuSe{width:32px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.purZT-SxQuSe{width:20px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK{border-radius:20px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK.pSzOP-SxQuSe{border-radius:16px}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK.purZT-SxQuSe{border-radius:10px}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc{border:none;color:#fff}.nsm7Bb-HzV7m-LgbsSe.MFS4be-v3pZbf-Ia7Qfc{background-color:#1a73e8}.nsm7Bb-HzV7m-LgbsSe.MFS4be-JaPV2b-Ia7Qfc{background-color:#202124;color:#e8eaed}@media screen and (prefers-contrast:more){.nsm7Bb-HzV7m-LgbsSe.MFS4be-JaPV2b-Ia7Qfc{color:#fff}}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:18px;margin-right:8px;min-width:18px;width:18px}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:14px;min-width:14px;width:14px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{height:10px;min-width:10px;width:10px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin-left:8px;margin-right:-4px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin:0;padding:10px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{padding:8px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c{padding:4px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{border-top-left-radius:3px;border-bottom-left-radius:3px;display:-webkit-box;display:-webkit-flex;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;justify-content:center;-webkit-box-align:center;-webkit-align-items:center;align-items:center;background-color:#fff;height:36px;margin-left:-10px;margin-right:12px;min-width:36px;width:36px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf .nsm7Bb-HzV7m-LgbsSe-Bz112c,.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf .nsm7Bb-HzV7m-LgbsSe-Bz112c{margin:0;padding:0}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{height:28px;margin-left:-8px;margin-right:10px;min-width:28px;width:28px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{height:16px;margin-left:-6px;margin-right:8px;min-width:16px;width:16px}.nsm7Bb-HzV7m-LgbsSe.Bz112c-LgbsSe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{border-radius:3px;margin-left:2px;margin-right:0;padding:0}.nsm7Bb-HzV7m-LgbsSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{border-radius:18px}.nsm7Bb-HzV7m-LgbsSe.pSzOP-SxQuSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{border-radius:14px}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{border-radius:8px}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-bN97Pc-sM5MNb{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-align-items:center;-webkit-box-align:center;align-items:center;-webkit-flex-direction:row;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-direction:row;-webkit-box-pack:justify;-webkit-justify-content:space-between;justify-content:space-between;-webkit-flex-wrap:nowrap;flex-wrap:nowrap;height:100%;position:relative;width:100%}.nsm7Bb-HzV7m-LgbsSe .oXtfBe-l4eHX{-webkit-box-pack:center;-webkit-justify-content:center;justify-content:center}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-BPrWId{-webkit-flex-grow:1;-webkit-box-flex:1;flex-grow:1;font-family:"Google Sans",arial,sans-serif;font-weight:500;overflow:hidden;text-overflow:ellipsis;vertical-align:top}.nsm7Bb-HzV7m-LgbsSe.purZT-SxQuSe .nsm7Bb-HzV7m-LgbsSe-BPrWId{font-weight:300}.nsm7Bb-HzV7m-LgbsSe .oXtfBe-l4eHX .nsm7Bb-HzV7m-LgbsSe-BPrWId{-webkit-flex-grow:0;-webkit-box-flex:0;flex-grow:0}.nsm7Bb-HzV7m-LgbsSe .nsm7Bb-HzV7m-LgbsSe-MJoBVe{-webkit-transition:background-color .218s;transition:background-color .218s;bottom:0;left:0;position:absolute;right:0;top:0}.nsm7Bb-HzV7m-LgbsSe:hover,.nsm7Bb-HzV7m-LgbsSe:focus{box-shadow:none;border-color:rgb(210,227,252);outline:none}.nsm7Bb-HzV7m-LgbsSe:focus-within{outline:2px solid #00639b;border-color:transparent}.nsm7Bb-HzV7m-LgbsSe:hover .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(66,133,244,.08)}.nsm7Bb-HzV7m-LgbsSe:active .nsm7Bb-HzV7m-LgbsSe-MJoBVe,.nsm7Bb-HzV7m-LgbsSe:focus .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(66,133,244,.1)}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:hover .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(255,255,255,.24)}.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:active .nsm7Bb-HzV7m-LgbsSe-MJoBVe,.nsm7Bb-HzV7m-LgbsSe.MFS4be-Ia7Qfc:focus .nsm7Bb-HzV7m-LgbsSe-MJoBVe{background:rgba(255,255,255,.32)}.nsm7Bb-HzV7m-LgbsSe .n1UuX-DkfjY{border-radius:50%;display:-webkit-box;display:-webkit-flex;display:flex;height:20px;margin-left:-4px;margin-right:8px;min-width:20px;width:20px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId{font-family:"Roboto";font-size:12px;text-align:left}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .ssJRIf,.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff .fmcmS{overflow:hidden;text-overflow:ellipsis}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff{display:-webkit-box;display:-webkit-flex;display:flex;-webkit-align-items:center;-webkit-box-align:center;align-items:center;color:#5f6368;fill:#5f6368;font-size:11px;font-weight:400}.nsm7Bb-HzV7m-LgbsSe.jVeSEe.MFS4be-Ia7Qfc .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff{color:#e8eaed;fill:#e8eaed}@media screen and (prefers-contrast:more){.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff,.nsm7Bb-HzV7m-LgbsSe.jVeSEe.MFS4be-Ia7Qfc .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff{color:#000;fill:#000}}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-BPrWId .K4efff .Bz112c{height:18px;margin:-3px -3px -3px 2px;min-width:18px;width:18px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:3px;border-bottom-right-radius:3px;margin-left:12px;margin-right:-10px}.nsm7Bb-HzV7m-LgbsSe.jVeSEe.JGcpL-RbRzK .nsm7Bb-HzV7m-LgbsSe-Bz112c-haAclf{border-radius:18px}.L5Fo6c-sM5MNb{border:0;display:block;left:0;position:relative;top:0}.L5Fo6c-bF1uUb{border-radius:4px;bottom:0;cursor:pointer;left:0;position:absolute;right:0;top:0}.L5Fo6c-bF1uUb:focus{border:none;outline:none}sentinel{}</style></head>
<body>
  <div class="wrap">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:10px;flex-wrap:wrap;">
        <div>
          <h1>
            Consultation Meeting Processor
            <span class="version">v0.6</span>
          </h1>
          <div class="muted">
            Pick a consultation event, upload the audio or a text transcript, get a transcript, structured summary,
            suggested kit from your spreadsheet template, and a proposal draft.
          </div>
        </div>
        <a href="https://frazerboorman.github.io/" class="pill">Frazer · AVD TOOLS</a>
      </div>

      <!-- STEP 1 – Calendar event -->
      <div class="section">
        <div class="section-title">Step 1 – Select consultation from Google Calendar</div>
        <div class="grid">
          <div>
            <label for="calendarId">Calendar ID</label>
            <input id="calendarId" value="bb14db72acb2ffd4230316960d02103fa66e54901522ff7b8113eec682f6d42e@group.calendar.google.com">
            <div class="small-note">
              Same calendar you use in the other tools.
            </div>
          </div>
          <div>
            <label for="eventSelect">Recent events (last 14 days + today)</label>
            <select id="eventSelect">
              <option value="">Sign in to load events…</option>
            </select>
            <div id="status" class="">Status: Waiting for sign-in…</div>
            <div id="aiStatus" class="">Running AI Debugger…</div>
          </div>
          <div style="align-self:end;">
            <button id="signinBtn" class="primary" type="button">Sign into Google</button>
            <div class="small-note">
              Same OAuth flow as the other tools.
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 2 – Audio upload + processing -->
      <div class="section">
        <div class="section-title">Step 2 – Upload consultation audio &amp; process</div>
        <div class="grid">
          <div>
            <label for="audioFile">Consultation audio / text file</label>
            <input id="audioFile" type="file" accept="audio/*,text/plain">
            <div class="small-note">
              Export from DJI Mic / Voice Memos first, or upload a .txt transcript. File only goes to OpenAI when transcribing.
              Whisper supports files up to ~25 MB per request; larger recordings will be split into chunks automatically.
            </div>
          </div>
        </div>

        <div class="btn-row">
          <button id="processBtn" class="primary" type="button">Process meeting (transcribe + summarise)</button>
        </div>
        <div class="small-note">
          Uses your OpenAI key stored in this browser (see “API key” panel below).
        </div>

        <div style="margin-top:10px;" class="grid">
          <div>
            <details class="transcript" id="transcriptDetails">
              <summary>Show full transcript</summary>
              <div class="transcript-body" id="transcriptBox">No transcript yet.</div>
            </details>
          </div>
          <div>
            <div class="summary-box">
              <h2>Consultation summary</h2>
              <div id="summaryBox">No summary yet.</div>
            </div>
          </div>
        </div>

        <div class="grid" style="margin-top:10px;">
          <div class="summary-box">
            <h2>Key issues</h2>
            <div id="issuesBox">–</div>
          </div>
          <div class="summary-box">
            <h2>Current equipment</h2>
            <div id="equipmentBox">–</div>
          </div>
        </div>

        <div class="summary-box" style="margin-top:10px;">
          <h2>Agreed / preferred solution</h2>
          <div id="solutionBox">–</div>
        </div>

        <details class="debug" style="margin-top:8px;">
          <summary>Debug view (structured AI JSON from transcript)</summary>
          <pre id="debugJson"></pre>
        </details>
      </div>

      <!-- STEP 3 – Spreadsheet template / product suggestions -->
      <div class="section">
        <div class="section-title">Step 3 – Suggest products from template spreadsheet</div>
        <div class="grid">
          <div>
            <label for="templateFile">Upload template spreadsheet (with “Products” sheet)</label>
            <input id="templateFile" type="file" accept=".xlsx,.xlsm,.xls">
            <div class="small-note">
              This should be your master template. The tool reads the <strong>Products</strong> sheet,
              then writes selected rows into a new <strong>AutoSelected</strong> sheet rather than touching your formulas.
            </div>
          </div>
        </div>

        <div class="btn-row">
          <button id="generateProductsBtn" type="button">Generate product checklist (from summary + Products sheet)</button>
          <button id="downloadFilledTemplateBtn" type="button">Download workbook with AutoSelected</button>
        </div>

        <div class="small-note">
          Review the suggested products before you commit. Quantities &amp; notes come from the transcript where possible.
        </div>

        <div style="margin-top:10px;">
          <label>Suggested products (preview)</label>
          <div id="productsTableWrapper">No products suggested yet.</div>
        </div>
      </div>

      <!-- STEP 4 – Proposal generator -->
      <div class="section">
        <div class="section-title">Step 4 – Proposal generator (from priced spreadsheet)</div>
        <div class="grid">
          <div>
            <label for="pricedFile">Upload edited/priced spreadsheet</label>
            <input id="pricedFile" type="file" accept=".xlsx,.xlsm,.xls">
            <div class="small-note">
              Use the template you’ve filled with prices, labour, totals etc.
              The tool will read the <strong>Clean</strong> sheet if present, otherwise the first sheet.
            </div>
          </div>
        </div>

        <div class="btn-row">
          <button id="generateProposalBtn" type="button" class="primary">Generate proposal / quote</button>
          <button id="downloadProposalDocBtn" type="button">Download proposal as Word (.doc)</button>
        </div>

        <div style="margin-top:10px;">
          <label>Proposal preview</label>
          <div id="proposalPreview">No proposal generated yet.</div>
        </div>
      </div>
    </div>

    <!-- API KEY PANEL -->
    <details class="api">
      <summary>API key (OpenAI) – hidden by default</summary>
      <div class="small-note" style="margin-top:4px;">
        Stored locally in <code>localStorage['avd_job_report_openai_key']</code>. Never sent anywhere except OpenAI’s API.
      </div>
      <div style="display:flex;gap:6px;align-items:center;margin-top:6px;flex-wrap:wrap;">
        <input id="apiKeyInput" type="password" placeholder="sk-..." style="flex:1 1 220px;max-width:380px;">
        <button type="button" id="saveApiKeyBtn">Save</button>
        <button type="button" id="clearApiKeyBtn">Forget</button>
      </div>
      <div id="apiKeyStatus" class="small-note">API key is stored in this browser.</div>
    </details>

    <!-- Global debug panel -->
    <details class="debug" open="">
      <summary>Debug panel</summary>
      <pre id="debugLog">(empty)[2025-11-29 12:28:37] DOM loaded.
[2025-11-29 12:28:38] STATUS: Waiting for sign-in…
[2025-11-29 12:28:38] Google auth library not ready yet.
[2025-11-29 12:29:03] AI: Uploading and transcribing / reading…
[2025-11-29 12:29:03] Processing file: New Recording 22.m4a (audio/x-m4a, 2978188 bytes)
[2025-11-29 12:29:03] Audio file size 2.8 MB – single Whisper call.
[2025-11-29 12:29:03] Sending audio chunk 1/1 to OpenAI whisper…
[2025-11-29 12:29:07] AI: Audio transcription error (chunk 1/1) 400: {"error":{"message":"Invalid file format. Supported formats: ['flac', 'm4a', 'mp3', 'mp4', 'mpeg', 'mpga', 'oga', 'ogg', 'wav', 'webm']","type":"invalid_request_error","param":null,"code":null},"usage":{"type":"duration","seconds":0}}
[2025-11-29 12:29:30] AI: Running AI Debugger…
[2025-11-29 12:29:30] AI Debugger invoked.
</pre>
    </details>

    <!-- AI Debugger panel -->
    <details class="debug" open="">
      <summary>AI Debugger (Be Strict)</summary>
      <div class="small-note" style="margin-top:4px;">
        Sends the full current index.html, internal debug log, structured AI JSON, and captured browser errors to the 5.1 model.
        It will either propose a minimal code fix with a full replacement index, or explain why the issue is external.
      </div>
      <div style="margin-top:6px;">
        <button type="button" id="runAiDebuggerBtn" disabled="">Run AI Debugger (index + debug log)</button>
      </div>
      <div class="small-note" style="margin-top:6px;">
        Optional: paste any extra console messages here if you’ve copied them from DevTools:
      </div>
      <textarea id="consoleErrorsInput" rows="4" style="margin-top:4px;"></textarea>
      <div class="small-note" style="margin-top:6px;">
        AI Debugger output (summary, reasons, and outline of changes):
      </div>
      <pre id="aiDebuggerOutput"></pre>
    </details>

    <!-- Replacement Index panel -->
    <details class="debug">
      <summary>Replacement index (from AI Debugger)</summary>
      <div class="small-note" style="margin-top:4px;">
        If the AI Debugger can fix the problem in code, it will provide a complete replacement index.html here.
        If the issue is external, this area will contain a prompt you can paste into ChatGPT for deeper help.
      </div>
      <pre id="replacementIndexOutput">(none yet)</pre>
    </details>
  </div>

  <script>
    // =========================
    // CONFIG / SHARED CONSTANTS
    // =========================
    const CLIENT_ID = "105230737516-l8tlnck4idde83pjetrotobpt8borvts.apps.googleusercontent.com";
    const SCOPES   = "https://www.googleapis.com/auth/calendar.readonly";
    const OPENAI_KEY_STORAGE = "avd_job_report_openai_key";
    const TEXT_MODEL = "gpt-4.1-mini";
    const AUDIO_MODEL = "whisper-1";
    const DEBUG_MODEL = "gpt-5.1";

    let tokenClient = null;
    let accessToken = null;
    let currentEvents = [];
    let lastTranscript = "";
    let lastStructuredSummary = null;
    let lastProductSelection = null;
    let lastProposalText = "";
    let browserErrorLog = [];

    // ==============
    // DEBUG LOGGER
    // ==============
    function logDebug(msg) {
      try {
        const el = document.getElementById("debugLog");
        if (!el) return;
        const ts = new Date().toISOString().replace("T"," ").slice(0,19);
        el.textContent += "[" + ts + "] " + msg + "\n";
        el.scrollTop = el.scrollHeight;
      } catch (e) {
        if (console && console.warn) console.warn("debugLog error", e);
      }
    }

    // ==============
    // STATUS HELPERS
    // ==============
    function setStatus(msg, isError) {
      const el = document.getElementById("status");
      if (!el) return;
      el.textContent = "Status: " + msg;
      el.className = isError ? "danger" : "";
      logDebug("STATUS: " + msg);
    }

    function setAiStatus(msg, isError) {
      const el = document.getElementById("aiStatus");
      if (!el) return;
      el.textContent = msg || "";
      el.className = isError ? "danger" : "";
      if (msg) logDebug("AI: " + msg);
    }

    function escapeHtml(str) {
      return String(str || "")
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;");
    }

    // ======================
    // GOOGLE AUTH & CALENDAR
    // ======================
    function getEventStartDate(ev) {
      if (!ev || !ev.start) return null;
      if (ev.start.date) return new Date(ev.start.date + "T00:00:00Z");
      if (ev.start.dateTime) return new Date(ev.start.dateTime);
      return null;
    }
    function extractEventDate(ev) {
      if (!ev || !ev.start) return "";
      if (ev.start.date) return ev.start.date;
      if (ev.start.dateTime) return ev.start.dateTime.slice(0,10);
      return "";
    }

    function initAuth() {
      if (!window.google || !google.accounts || !google.accounts.oauth2) {
        logDebug("Google auth library not ready yet.");
        return;
      }
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        prompt: "",
        callback: (resp) => {
          if (resp && resp.access_token) {
            accessToken = resp.access_token;
            setStatus("Signed in. Loading events…", false);
            loadRecentEvents();
          } else {
            setStatus("Sign-in failed.", true);
          }
        }
      });
      logDebug("Google tokenClient initialised.");
    }

    function signInManual() {
      if (!tokenClient) initAuth();
      if (!tokenClient) {
        setStatus("Google auth not ready.", true);
        return;
      }
      logDebug("Requesting Google access token…");
      tokenClient.requestAccessToken();
    }

    async function loadRecentEvents() {
      if (!accessToken) {
        setStatus("No access token yet.", true);
        return;
      }
      const calId = (document.getElementById("calendarId").value || "primary").trim();

      const now = new Date();
      const end = new Date(now);
      end.setHours(23,59,59,999);
      const start = new Date(now);
      start.setDate(start.getDate() - 14);
      start.setHours(0,0,0,0);

      const url = new URL(
        "https://www.googleapis.com/calendar/v3/calendars/" +
        encodeURIComponent(calId) +
        "/events"
      );
      url.searchParams.set("singleEvents","true");
      url.searchParams.set("orderBy","startTime");
      url.searchParams.set("timeMin", start.toISOString());
      url.searchParams.set("timeMax", end.toISOString());
      url.searchParams.set("maxResults","250");

      logDebug("Fetching events: " + url.toString());

      const res = await fetch(url.toString(), {
        headers: { "Authorization":"Bearer " + accessToken }
      });
      if (!res.ok) {
        setStatus("Calendar API error " + res.status, true);
        return;
      }
      const data = await res.json();
      const items = data.items || [];
      const nowRef = new Date();

      const processed = items
        .map(ev => ({ ev, startDate: getEventStartDate(ev) }))
        .filter(obj => obj.startDate && obj.startDate <= nowRef)
        .sort((a,b) => b.startDate - a.startDate);

      currentEvents = processed.map(x => x.ev);

      const sel = document.getElementById("eventSelect");
      sel.innerHTML = "";
      if (!currentEvents.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No events in last 14 days.";
        sel.appendChild(opt);
        setStatus("No recent events found.", false);
        return;
      }

      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "— Select consultation —";
      sel.appendChild(placeholder);

      currentEvents.forEach((ev, idx) => {
        const title = ev.summary || "(no title)";
        const d = extractEventDate(ev);
        const opt = document.createElement("option");
        opt.value = String(idx);
        opt.textContent = (d ? (d + " – ") : "") + title;
        sel.appendChild(opt);
      });

      setStatus("Loaded " + currentEvents.length + " events.", false);
      logDebug("Loaded " + currentEvents.length + " events.");
    }

    // ===================
    // OPENAI: AUDIO + NLP
    // ===================
    function getOpenAIKeyOrThrow() {
      const key = localStorage.getItem(OPENAI_KEY_STORAGE);
      if (!key) {
        throw new Error("No OpenAI API key found. Set it in the API key panel.");
      }
      return key;
    }

    async function transcribeAudioChunk(blob, apiKey, partIndex, totalParts) {
      const formData = new FormData();
      // Normalise MIME type for Whisper: some browsers use audio/x-m4a which can be rejected.
      let uploadBlob = blob;
      try {
        const originalType = blob.type || "";
        let forcedType = originalType;
        if (!originalType && typeof Blob !== "undefined") {
          // Leave as-is if we have no type at all.
          forcedType = "";
        } else if (/x-m4a$/i.test(originalType)) {
          // Normalise audio/x-m4a to audio/m4a which Whisper explicitly supports.
          forcedType = "audio/m4a";
        }
        if (forcedType && forcedType !== originalType && typeof Blob !== "undefined") {
          uploadBlob = new Blob([blob], { type: forcedType });
        }
      } catch (e) {
        // If anything goes wrong, fall back to the original blob.
      }
      formData.append("file", uploadBlob, "chunk-" + partIndex + ".m4a");
      formData.append("model", AUDIO_MODEL);
      formData.append("response_format","json");

      logDebug("Sending audio chunk " + partIndex + "/" + totalParts + " to OpenAI whisper…");

      const res = await fetch("https://api.openai.com/v1/audio/transcriptions", {
        method: "POST",
        headers: {
          "Authorization": "Bearer " + apiKey
        },
        body: formData
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error("Audio transcription error (chunk " + partIndex + "/" + totalParts + ") " + res.status + ": " + txt);
      }
      const data = await res.json();
      return data.text || "";
    }

    async function transcribeAudio(file) {
      const apiKey = getOpenAIKeyOrThrow();

      // Text file path
      if (file.type === "text/plain" || file.name.toLowerCase().endsWith(".txt")) {
        logDebug("Treating file as plain text transcript: " + file.name);
        const text = await file.text();
        return text || "";
      }

      const MAX_CHUNK_BYTES = 24 * 1024 * 1024; // Keep under 25 MB Whisper limit per request

      if (file.size <= MAX_CHUNK_BYTES) {
        logDebug("Audio file size " + (file.size / (1024 * 1024)).toFixed(1) + " MB – single Whisper call.");
        return await transcribeAudioChunk(file, apiKey, 1, 1);
      }

      const totalParts = Math.ceil(file.size / MAX_CHUNK_BYTES);
      logDebug(
        "Audio file size " +
        (file.size / (1024 * 1024)).toFixed(1) +
        " MB – splitting into " + totalParts + " chunks for Whisper."
      );
      setAiStatus("Large audio – uploading in chunks for transcription…", false);

      let combinedText = "";
      for (let part = 0; part < totalParts; part++) {
        const start = part * MAX_CHUNK_BYTES;
        const end = Math.min(file.size, start + MAX_CHUNK_BYTES);
        const chunk = file.slice(start, end);
        const partIndex = part + 1;
        logDebug("Preparing chunk " + partIndex + "/" + totalParts + " (" +
          ((end - start) / (1024 * 1024)).toFixed(1) + " MB).");
        const chunkText = await transcribeAudioChunk(chunk, apiKey, partIndex, totalParts);
        if (chunkText) {
          combinedText += (combinedText ? "\n\n" : "") + chunkText;
        }
      }
      return combinedText;
    }

    async function summariseTranscript(transcript, eventMeta) {
      const apiKey = getOpenAIKeyOrThrow();
      const systemPrompt =
        "You are processing a recorded AV consultation meeting between an engineer and client.\n" +
        "You receive the full transcript as plain text and some optional calendar event metadata.\n\n" +
        "GOALS:\n" +
        "1) Produce a concise consultation summary for the engineer, not the client.\n" +
        "2) Identify key issues the client is facing (bullet points).\n" +
        "3) Identify current equipment and, where stated, whether it works, is failing, or is unknown.\n" +
        "4) Identify the final agreed / preferred solution, not just options that were discussed and rejected.\n" +
        "5) Produce a 'productNeeds' list the system can use later to pick products from a spreadsheet.\n\n" +
        "Rules:\n" +
        "- Read the ENTIRE transcript before deciding what was actually agreed.\n" +
        "- If something was clearly rejected, do NOT list it as part of the final solution.\n" +
        "- Do NOT invent any kit or decisions that are not in the transcript.\n" +
        "- productNeeds items should be high-level roles like 'ceiling speakers for main hall', '4K projector',\n" +
        "  'HDMI wall plate', 'wireless handheld microphone', etc.\n\n" +
        "Return STRICT JSON ONLY in this format:\n" +
        "{\n" +
        '  \"summary\": \"Short paragraph summarising the meeting from the engineer’s perspective.\",\n' +
        '  \"keyIssues\": [\"issue 1\", \"issue 2\", \"...\"],\n' +
        '  \"currentEquipment\": [\n' +
        '    { \"name\": \"\", \"status\": \"working | failing | unknown\", \"notes\": \"\" }\n' +
        '  ],\n' +
        '  \"agreedSolution\": \"Paragraph describing final agreed solution.\",\n' +
        '  \"productNeeds\": [\n' +
        '    {\n' +
        '      \"categoryHint\": \"Audio | Visual | Control | Streaming | Infrastructure | Other\",\n' +
        '      \"role\": \"e.g. ceiling speakers, projector, wall plate, amp, etc.\",\n' +
        '      \"quantity\": 0,\n' +
        '      \"extraNotes\": \"any constraints mentioned (e.g. white finish, left wall, balcony, etc.)\"\n' +
        '    }\n' +
        '  ]\n' +
        "}\n" +
        "No explanatory text outside the JSON.";

      const payload = { transcript, eventMeta };

      logDebug("Sending transcript to OpenAI for structured summary…");

      const res = await fetch("https://api.openai.com/v1/responses", {
        method: "POST",
        headers: {
          "Content-Type":"application/json",
          "Authorization":"Bearer " + apiKey
        },
        body: JSON.stringify({
          model: TEXT_MODEL,
          input: [
            { role:"system", content: systemPrompt },
            { role:"user", content: JSON.stringify(payload) }
          ]
        })
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error("Summary AI error " + res.status + ": " + txt);
      }
      const data = await res.json();
      let rawText = "";
      if (
        data.output &&
        data.output[0] &&
        data.output[0].content &&
        data.output[0].content[0] &&
        data.output[0].content[0].text
      ) {
        rawText = data.output[0].content[0].text;
      } else {
        throw new Error("Unexpected AI summary response shape.");
      }

      let parsed;
      try {
        parsed = JSON.parse(rawText);
      } catch (e) {
        console.error("Failed to parse AI JSON:", rawText);
        throw new Error("Failed to parse AI JSON summary.");
      }
      logDebug("Structured summary parsed.");
      return parsed;
    }

    async function handleProcessMeeting() {
      const fileInput = document.getElementById("audioFile");
      const file = fileInput.files && fileInput.files[0];
      if (!file) {
        setAiStatus("Please choose an audio or text file first.", true);
        return;
      }

      document.getElementById("processBtn").disabled = true;
      setAiStatus("Uploading and transcribing / reading…", false);
      logDebug("Processing file: " + file.name + " (" + file.type + ", " + file.size + " bytes)");

      try {
        const eventSel = document.getElementById("eventSelect");
        let eventMeta = null;
        if (eventSel.value) {
          const ev = currentEvents[Number(eventSel.value)];
          if (ev) {
            eventMeta = {
              title: ev.summary || "",
              description: ev.description || "",
              location: ev.location || "",
              start: ev.start || {}
            };
          }
        }

        const transcript = await transcribeAudio(file);
        lastTranscript = transcript || "";

        document.getElementById("transcriptBox").textContent =
          transcript ? transcript : "Transcription / text returned empty.";

        setAiStatus("Transcribed / loaded. Summarising and structuring…", false);

        const structured = await summariseTranscript(transcript, eventMeta);
        lastStructuredSummary = structured;

        // Render into UI
        document.getElementById("summaryBox").innerHTML =
          structured.summary
            ? escapeHtml(structured.summary).replace(/\n/g,"<br>")
            : "No summary returned.";

        if (Array.isArray(structured.keyIssues) && structured.keyIssues.length) {
          document.getElementById("issuesBox").innerHTML =
            "<ul>" + structured.keyIssues
              .map(i => "<li>" + escapeHtml(i) + "</li>")
              .join("") + "</ul>";
        } else {
          document.getElementById("issuesBox").textContent = "No key issues extracted.";
        }

        if (Array.isArray(structured.currentEquipment) && structured.currentEquipment.length) {
          const lis = structured.currentEquipment.map(eq => {
            const name = eq.name || "-";
            const status = eq.status || "unknown";
            const notes = eq.notes || "";
            let line = "<strong>" + escapeHtml(name) + "</strong> (" + escapeHtml(status) + ")";
            if (notes) line += " – " + escapeHtml(notes);
            return "<li>" + line + "</li>";
          }).join("");
          document.getElementById("equipmentBox").innerHTML = "<ul>" + lis + "</ul>";
        } else {
          document.getElementById("equipmentBox").textContent = "No equipment explicitly mentioned.";
        }

        document.getElementById("solutionBox").innerHTML =
          structured.agreedSolution
            ? escapeHtml(structured.agreedSolution).replace(/\n/g,"<br>")
            : "No final solution clearly extracted.";

        document.getElementById("debugJson").textContent =
          JSON.stringify(structured, null, 2);

        setAiStatus("Transcript and summary ready. Review summary before product selection.", false);
      } catch (e) {
        console.error(e);
        setAiStatus(e.message || "Error processing meeting.", true);
      } finally {
        document.getElementById("processBtn").disabled = false;
      }
    }

    // ===========================
    // STEP 3: PRODUCTS / TEMPLATE
    // ===========================
    async function handleGenerateProducts() {
      if (!lastStructuredSummary) {
        setAiStatus("Process the meeting first to get a structured summary.", true);
        return;
      }
      if (typeof XLSX === "undefined") {
        setAiStatus("Spreadsheet library (XLSX) is not available – wait a moment and try again.", true);
        logDebug("handleGenerateProducts: XLSX is undefined.");
        return;
      }

      const fileInput = document.getElementById("templateFile");
      const file = fileInput.files && fileInput.files[0];
      if (!file) {
        setAiStatus("Upload your template spreadsheet (with Products sheet) first.", true);
        return;
      }

      setAiStatus("Reading template & sending to AI for product selection…", false);
      document.getElementById("generateProductsBtn").disabled = true;

      try {
        const arrayBuffer = await file.arrayBuffer();
        const wb = XLSX.read(arrayBuffer, { type:"array" });

        const productsSheet = wb.Sheets["Products"];
        if (!productsSheet) {
          throw new Error("No 'Products' sheet found in template.");
        }

        const rows = XLSX.utils.sheet_to_json(productsSheet, { header:1 });
        if (!rows.length) {
          throw new Error("Products sheet is empty.");
        }

        const headers = rows[0];
        const dataRows = rows.slice(1);

        const productTableForAI = dataRows.map((row, idx) => {
          const obj = { rowIndex: idx + 2 };
          headers.forEach((h, colIdx) => {
            if (!h) return;
            obj[String(h)] = row[colIdx];
          });
          return obj;
        });

        const apiKey = getOpenAIKeyOrThrow();
        const systemPrompt =
          "You are helping choose products from an AV company's master 'Products' sheet.\n" +
          "You receive:\n" +
          "- A structured consultation summary with productNeeds.\n" +
          "- A list of products from the 'Products' sheet, with their columns exactly as given.\n\n" +
          "Your job:\n" +
          "- For each product need, choose the most appropriate product(s) from the list.\n" +
          "- Decide which checklist the product should appear in: 'Audio', 'Visual', 'Control', 'Streaming', 'Infrastructure', or 'Other'.\n" +
          "- Suggest a quantity (0 if you really cannot tell, but try to infer from the needs).\n" +
          "- Add a short notes field with key details (e.g. 'Combi JTS RX – 1 HH + 1 belt-pack', 'White finish', 'Left wall mount', etc.).\n\n" +
          "Rules:\n" +
          "- Do NOT invent product names not present in the products table.\n" +
          "- You may choose multiple products for a single need if sensible (e.g. projector + mount + wallplate).\n" +
          "- If the products sheet has a column that clearly indicates its natural checklist (e.g. 'Category'), use it.\n" +
          "- If multiple products fit, choose the most likely / standard option.\n\n" +
          "Return STRICT JSON ONLY in this format:\n" +
          "{\n" +
          '  \"items\": [\n' +
          "    {\n" +
          '      \"rowIndex\": 0,\n' +
          '      \"checklist\": \"Audio | Visual | Control | Streaming | Infrastructure | Other\",\n' +
          '      \"quantity\": 0,\n' +
          '      \"notes\": \"short engineer-facing note\",\n' +
          '      \"reason\": \"why this product was chosen (brief)\",\n' +
          '      \"productSnapshot\": { }\n' +
          "    }\n" +
          "  ]\n" +
          "}\n" +
          "No explanatory text outside the JSON.";

        const payload = {
          structuredSummary: lastStructuredSummary,
          products: productTableForAI
        };

        const res = await fetch("https://api.openai.com/v1/responses", {
          method:"POST",
          headers:{
            "Content-Type":"application/json",
            "Authorization":"Bearer " + apiKey
          },
          body: JSON.stringify({
            model: TEXT_MODEL,
            input: [
              { role:"system", content: systemPrompt },
              { role:"user", content: JSON.stringify(payload) }
            ]
          })
        });
        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error("Product selection AI error " + res.status + ": " + txt);
        }
        const data = await res.json();
        let rawText = "";
        if (
          data.output &&
          data.output[0] &&
          data.output[0].content &&
          data.output[0].content[0] &&
          data.output[0].content[0].text
        ) {
          rawText = data.output[0].content[0].text;
        } else {
          throw new Error("Unexpected product AI response shape.");
        }

        let parsed;
        try {
          parsed = JSON.parse(rawText);
        } catch (e) {
          console.error("Product AI JSON parse failed:", rawText);
          throw new Error("Could not parse JSON from product AI.");
        }

        lastProductSelection = {
          workbook: wb,
          headers,
          rows,
          selection: parsed.items || []
        };

        renderProductSelectionTable(lastProductSelection);
        setAiStatus("Product suggestions generated. Review before downloading workbook.", false);
      } catch (e) {
        console.error(e);
        setAiStatus(e.message || "Error generating product suggestions.", true);
      } finally {
        document.getElementById("generateProductsBtn").disabled = false;
      }
    }

    function renderProductSelectionTable(state) {
      const wrap = document.getElementById("productsTableWrapper");
      if (!state || !state.selection || !state.selection.length) {
        wrap.textContent = "No products suggested.";
        return;
      }
      const rowsHtml = state.selection.map(item => {
        const rowIdx = item.rowIndex;
        const checklist = item.checklist || "";
        const qty = item.quantity != null ? String(item.quantity) : "";
        const notes = item.notes || "";
        const reason = item.reason || "";
        const snapshot = item.productSnapshot || {};
        const name = snapshot.Name || snapshot.name || snapshot.Product || "";
        return "<tr>" +
          "<td>" + escapeHtml(checklist) + "</td>" +
          "<td>" + escapeHtml(String(qty)) + "</td>" +
          "<td>" + escapeHtml(name || "[from row " + rowIdx + "]") + "</td>" +
          "<td>" + escapeHtml(notes) + "</td>" +
          "<td>" + escapeHtml(reason) + "</td>" +
        "</tr>";
      }).join("");

      wrap.innerHTML =
        "<table>" +
          "<thead><tr>" +
            "<th>Checklist</th>" +
            "<th>Qty</th>" +
            "<th>Product</th>" +
            "<th>Notes</th>" +
            "<th>Why chosen</th>" +
          "</tr></thead>" +
          "<tbody>" + rowsHtml + "</tbody>" +
        "</table>";
    }

    function handleDownloadFilledTemplate() {
      if (!lastProductSelection) {
        alert("Generate product suggestions first.");
        return;
      }
      const { workbook, selection } = lastProductSelection;
      const data = selection || [];
      if (!data.length) {
        alert("No suggested products to write.");
        return;
      }
      if (typeof XLSX === "undefined") {
        alert("Spreadsheet library (XLSX) is not available.");
        return;
      }

      const header = ["Checklist","Qty","RowIndex","Notes","Reason","ProductSnapshot"];
      const rows = [header];
      data.forEach(item => {
        rows.push([
          item.checklist || "",
          item.quantity != null ? item.quantity : "",
          item.rowIndex != null ? item.rowIndex : "",
          item.notes || "",
          item.reason || "",
          JSON.stringify(item.productSnapshot || {})
        ]);
      });
      const ws = XLSX.utils.aoa_to_sheet(rows);
      workbook.Sheets["AutoSelected"] = ws;
      if (!workbook.SheetNames.includes("AutoSelected")) {
        workbook.SheetNames.push("AutoSelected");
      }

      const wbout = XLSX.write(workbook, { bookType:"xlsx", type:"array" });
      const blob = new Blob([wbout], { type:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "template_with_autoselected.xlsx";
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
      }, 0);
    }

    // ======================
    // STEP 4: PROPOSAL / QUOTE
    // ======================
    async function handleGenerateProposal() {
      const pricedInput = document.getElementById("pricedFile");
      const file = pricedInput.files && pricedInput.files[0];
      if (!file) {
        setAiStatus("Upload your priced spreadsheet first.", true);
        return;
      }
      if (typeof XLSX === "undefined") {
        setAiStatus("Spreadsheet library (XLSX) is not available.", true);
        return;
      }

      document.getElementById("generateProposalBtn").disabled = true;
      setAiStatus("Reading priced sheet & generating proposal…", false);

      try {
        const arrayBuffer = await file.arrayBuffer();
        const wb = XLSX.read(arrayBuffer, { type:"array" });

        let sheetName = "Clean";
        if (!wb.Sheets[sheetName]) {
          sheetName = wb.SheetNames[0];
        }
        const sheet = wb.Sheets[sheetName];
        if (!sheet) throw new Error("No usable sheet found in priced workbook.");
        const table = XLSX.utils.sheet_to_json(sheet, { header:1 });

        const apiKey = getOpenAIKeyOrThrow();
        const systemPrompt =
          "You are generating a client-facing AV proposal/quote based on a priced spreadsheet and a consultation summary.\n\n" +
          "You will receive:\n" +
          "- A structured consultation summary (issues, current equipment, agreed solution).\n" +
          "- A table from the 'Clean' (or equivalent) sheet of a spreadsheet that includes products, prices, quantities, totals, and possibly labour/time.\n\n" +
          "Your job:\n" +
          "1) Identify the main components that should be described in the proposal (projectors, screens/TVs, main speakers, amps, microphones, key control hardware, streaming hardware etc.).\n" +
          "   Do NOT write paragraphs about minor items (mounts, brackets, small accessories).\n" +
          "2) For each main component, write a short, clear description referencing relevant details from the consultation summary\n" +
          "   (e.g. mounting position like 'left wall', use-cases like film nights, speech clarity, etc.).\n" +
          "3) Group costs sensibly (e.g. Audio, Visual, Control, Infrastructure, Labour) and show totals per group plus a grand total.\n" +
          "4) Mention estimated days on site, based on any labour/time information in the table (if present). If there is genuinely no\n" +
          "   indication of labour/time, say 'Installation duration to be confirmed'.\n" +
          "5) Write this as a proposal/quote that could be sent to the client, in clear UK English.\n\n" +
          "Rules:\n" +
          "- Do NOT invent extra products or prices. Work only from the spreadsheet table.\n" +
          "- You may infer reasonable grouping from column headers (e.g. 'Category', 'Checklist', etc.).\n" +
          "- Do NOT expose raw spreadsheet table in the body, but you can refer to product names.\n\n" +
          "Structure the output as:\n" +
          "1) Short opening paragraph referencing the client's situation.\n" +
          "2) Bullet list of key benefits of the proposed solution.\n" +
          "3) Headings for each main area (Audio System, Visual System, Control/Operation, Streaming/Broadcast, Infrastructure & Cabling, Labour & Timescales).\n" +
          "4) Under each heading, short paragraphs describing what is included.\n" +
          "5) Section with pricing breakdown per area and overall total.\n" +
          "6) Closing paragraph about next steps.\n";

        const payload = {
          structuredSummary: lastStructuredSummary,
          pricedSheetName: sheetName,
          pricedTable: table
        };

        const res = await fetch("https://api.openai.com/v1/responses", {
          method:"POST",
          headers:{
            "Content-Type":"application/json",
            "Authorization":"Bearer " + apiKey
          },
          body: JSON.stringify({
            model: TEXT_MODEL,
            input: [
              { role:"system", content: systemPrompt },
              { role:"user", content: JSON.stringify(payload) }
            ]
          })
        });

        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error("Proposal AI error " + res.status + ": " + txt);
        }
        const data = await res.json();
        let text = "";
        if (
          data.output &&
          data.output[0] &&
          data.output[0].content &&
          data.output[0].content[0] &&
          data.output[0].content[0].text
        ) {
          text = data.output[0].content[0].text;
        } else {
          throw new Error("Unexpected proposal response shape.");
        }

        lastProposalText = text;
        document.getElementById("proposalPreview").textContent = text;
        setAiStatus("Proposal generated. Review and tweak as needed.", false);
      } catch (e) {
        console.error(e);
        setAiStatus(e.message || "Error generating proposal.", true);
      } finally {
        document.getElementById("generateProposalBtn").disabled = false;
      }
    }

    function handleDownloadProposalDoc() {
      if (!lastProposalText) {
        alert("Generate a proposal first.");
        return;
      }
      const html =
        "<!doctype html><html><head><meta charset='utf-8'>" +
        "<title>Proposal</title>" +
        "<style>" +
        "body{font-family:Calibri,Arial,sans-serif;font-size:11pt;color:#000;}"+
        "h1,h2,h3{font-weight:bold;}"+
        "</style></head><body>" +
        "<pre style='white-space:pre-wrap;font-family:Calibri,Arial,sans-serif;'>" +
        escapeHtml(lastProposalText) +
        "</pre></body></html>";

      const blob = new Blob([html], { type:"application/msword" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "proposal.doc";
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
      }, 0);
    }

    // ====================
    // AI DEBUGGER LOGIC
    // ====================
    const aiDebuggerSystemPrompt =
      "You are an AI debugger for a single-page AV tool called 'Consultation Meeting Processor'.\\n" +
      "The tool is delivered as a single index.html and runs entirely in the browser (no backend).\\n" +
      "Your job is to review the current index.html source, the debug log, structured AI JSON, and browser errors to explain problems and propose minimal, safe fixes.\\n\\n" +
      "Important rules (labelled 'Be Strict'):\\n" +
      "1) Only change code when you can point to a concrete bug, missing handler, or clearly unsafe behaviour.\\n" +
      "2) Never rewrite or simplify working code.\\n" +
      "3) Keep all existing layout, styling, naming, and structure unless a specific bug forces a change.\\n" +
      "4) When you change code, you must:\\n" +
      "   - Explain the issue in plain language,\\n" +
      "   - Explain why your change fixes it,\\n" +
      "   - Describe exactly where the change belongs (function name or HTML section),\\n" +
      "   - Provide a full replacement index.html with your changes applied.\\n" +
      "5) The replacement index must be COMPLETE, from <!doctype html> to </html>, with NO truncation, ellipses, or placeholders.\\n" +
      "6) Do not invent external configuration fixes (API keys, account/project changes, quotas). If the problem is external, say so explicitly.\\n\\n" +
      "You will be given a JSON payload with:\\n" +
      "- toolName, versionPill\\n" +
      "- indexHtml (full current page source)\\n" +
      "- debugLog (internal debug text)\\n" +
      "- structuredJsonDebug (JSON from earlier AI calls, if any)\\n" +
      "- browserErrors (window.onerror / unhandledrejection text)\\n" +
      "- consoleExtra (freeform text pasted by the user)\\n\\n" +
      "You must respond with STRICT JSON in this shape:\\n" +
      "{\\n" +
      '  \"outcome\": \"code_fix\" | \"external_issue\" | \"no_issue\",\\n' +
      '  \"summary\": \"Short summary of what you found.\",\\n' +
      '  \"reasons\": [\"reason 1\", \"reason 2\", \"...\"],\\n' +
      '  \"changes\": [\\n' +
      "    {\\n" +
      '      \"section\": \"short label (e.g. transcribeAudio, Google auth)\",\\n' +
      '      \"reason\": \"why this section needs a change\",\\n' +
      '      \"beforeSnippet\": \"optional short snippet from the old code (can be empty)\",\\n' +
      '      \"afterSnippet\": \"the corresponding fixed snippet (can be empty if not applicable)\"\\n' +
      "    }\\n" +
      "  ],\\n" +
      '  \"replacementIndexHtml\": \"Full index.html with your fixes applied, or an empty string if no code changes are needed.\",\\n' +
      '  \"chatgptPrompt\": \"If outcome is external_issue, write a prompt the user can paste into ChatGPT to get further help. Otherwise empty string.\"\\n' +
      "}\\n" +
      "If you believe the issue cannot be solved by changing index.html (for example: account or quota issues, missing model access, or third-party service outages), set outcome to \\\"external_issue\\\" and do NOT propose code changes.";

    async function handleRunAiDebugger() {
      let apiKey;
      try {
        apiKey = getOpenAIKeyOrThrow();
      } catch (e) {
        setAiStatus(e.message || "No API key set for AI Debugger.", true);
        const outEl = document.getElementById("aiDebuggerOutput");
        if (outEl) outEl.textContent = e.message || "No API key set.";
        return;
      }

      const btn = document.getElementById("runAiDebuggerBtn");
      if (btn) btn.disabled = true;
      setAiStatus("Running AI Debugger…", false);
      logDebug("AI Debugger invoked.");

      const payload = {
        toolName: "Consultation Meeting Processor",
        versionPill: (document.querySelector(".version") && document.querySelector(".version").textContent) || "",
        indexHtml: document.documentElement.outerHTML,
        debugLog: (document.getElementById("debugLog") && document.getElementById("debugLog").textContent) || "",
        structuredJsonDebug: (document.getElementById("debugJson") && document.getElementById("debugJson").textContent) || "",
        browserErrors: browserErrorLog.slice(),
        consoleExtra: (document.getElementById("consoleErrorsInput") && document.getElementById("consoleErrorsInput").value) || ""
      };

      const outEl = document.getElementById("aiDebuggerOutput");
      const replEl = document.getElementById("replacementIndexOutput");

      try {
        const res = await fetch("https://api.openai.com/v1/responses", {
          method: "POST",
          headers: {
            "Content-Type":"application/json",
            "Authorization":"Bearer " + apiKey
          },
          body: JSON.stringify({
            model: DEBUG_MODEL,
            input: [
              { role:"system", content: aiDebuggerSystemPrompt },
              { role:"user", content: JSON.stringify(payload) }
            ]
          })
        });

        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error("AI Debugger error " + res.status + ": " + txt);
        }

        const data = await res.json();
        let rawText = "";
        if (
          data.output &&
          data.output[0] &&
          data.output[0].content &&
          data.output[0].content[0] &&
          data.output[0].content[0].text
        ) {
          rawText = data.output[0].content[0].text;
        } else {
          throw new Error("Unexpected AI Debugger response shape.");
        }

        let parsed;
        try {
          parsed = JSON.parse(rawText);
        } catch (e) {
          console.error("AI Debugger JSON parse failed:", rawText);
          throw new Error("AI Debugger JSON parse failed.");
        }

        const outcome = parsed.outcome || "no_issue";
        const summary = parsed.summary || "";
        const reasons = Array.isArray(parsed.reasons) ? parsed.reasons : [];
        const changes = Array.isArray(parsed.changes) ? parsed.changes : [];
        const replacementIndexHtml = parsed.replacementIndexHtml || "";
        const chatgptPrompt = parsed.chatgptPrompt || "";

        let outText = "";
        outText += "Outcome: " + outcome + "\n";
        if (summary) {
          outText += "\nSummary:\n" + summary + "\n";
        }
        if (reasons.length) {
          outText += "\nReasons:\n";
          reasons.forEach((r, idx) => {
            outText += "- " + r + "\n";
          });
        }
        if (changes.length) {
          outText += "\nChanges:\n";
          changes.forEach((c, idx) => {
            const section = c.section || ("Change " + (idx + 1));
            const reason = c.reason || "";
            outText += "* " + section + (reason ? " – " + reason : "") + "\n";
          });
        }

        if (outEl) outEl.textContent = outText || "(no details provided by AI Debugger)";

        if (replEl) {
          if (outcome === "code_fix" && replacementIndexHtml) {
            replEl.textContent = replacementIndexHtml;
          } else if (outcome === "external_issue" && chatgptPrompt) {
            replEl.textContent = chatgptPrompt;
          } else {
            replEl.textContent = "(no replacement index provided)";
          }
        }

        setAiStatus("AI Debugger finished. Review its output below.", false);
      } catch (e) {
        console.error(e);
        if (outEl) {
          outEl.textContent = e.message || "AI Debugger error.";
        }
        setAiStatus(e.message || "AI Debugger error.", true);
      } finally {
        if (btn) btn.disabled = false;
      }
    }

    // ====================
    // API KEY PANEL LOGIC
    // ====================
    function refreshApiKeyStatus() {
      const statusEl = document.getElementById("apiKeyStatus");
      const key = localStorage.getItem(OPENAI_KEY_STORAGE);
      if (key) {
        statusEl.textContent = "API key is stored in this browser.";
      } else {
        statusEl.textContent = "No API key stored yet.";
      }
    }

    function handleSaveApiKey() {
      const input = document.getElementById("apiKeyInput");
      const v = (input.value || "").trim();
      if (!v) {
        alert("Enter a key first.");
        return;
      }
      localStorage.setItem(OPENAI_KEY_STORAGE, v);
      input.value = "";
      refreshApiKeyStatus();
      logDebug("OpenAI key saved to localStorage.");
    }

    function handleClearApiKey() {
      localStorage.removeItem(OPENAI_KEY_STORAGE);
      refreshApiKeyStatus();
      logDebug("OpenAI key cleared from localStorage.");
    }

    // =========
    // INIT
    // =========
    window.addEventListener("DOMContentLoaded", () => {
      logDebug("DOM loaded.");

      // Capture browser-level errors into browserErrorLog and debug pane
      window.addEventListener("error", (event) => {
        const msg = (event.message || "Unknown error") +
          (event.filename ? (" @ " + event.filename + ":" + event.lineno + ":" + event.colno) : "");
        browserErrorLog.push(msg);
        logDebug("BROWSER ERROR: " + msg);
      });

      window.addEventListener("unhandledrejection", (event) => {
        const reason = event.reason;
        const msg = "Unhandled promise rejection: " + (reason && reason.message ? reason.message : String(reason || "unknown"));
        browserErrorLog.push(msg);
        logDebug("BROWSER ERROR: " + msg);
      });

      document.getElementById("signinBtn").addEventListener("click", signInManual);
      document.getElementById("processBtn").addEventListener("click", handleProcessMeeting);
      document.getElementById("generateProductsBtn").addEventListener("click", handleGenerateProducts);
      document.getElementById("downloadFilledTemplateBtn").addEventListener("click", handleDownloadFilledTemplate);
      document.getElementById("generateProposalBtn").addEventListener("click", handleGenerateProposal);
      document.getElementById("downloadProposalDocBtn").addEventListener("click", handleDownloadProposalDoc);

      const eventSelect = document.getElementById("eventSelect");
      eventSelect.addEventListener("change", () => {
        const idx = eventSelect.value;
        if (!idx) return;
        const ev = currentEvents[Number(idx)];
        if (ev) {
          setStatus("Selected: " + (ev.summary || "(no title)"), false);
        }
      });

      const runAiDebuggerBtn = document.getElementById("runAiDebuggerBtn");
      if (runAiDebuggerBtn) {
        runAiDebuggerBtn.addEventListener("click", handleRunAiDebugger);
      }

      // API key handlers
      document.getElementById("saveApiKeyBtn").addEventListener("click", handleSaveApiKey);
      document.getElementById("clearApiKeyBtn").addEventListener("click", handleClearApiKey);
      refreshApiKeyStatus();

      setStatus("Waiting for sign-in…", false);

      // Prepare Google auth client
      setTimeout(() => {
        try { initAuth(); } catch(e) { logDebug("initAuth error: " + e.message); }
      }, 0);
    });
  </script>


</body></html>
