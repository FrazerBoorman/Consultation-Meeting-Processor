<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Consultation Meeting Processor</title>
  <meta name="color-scheme" content="light dark" />
  <!-- Google OAuth client ID (same as other tools) -->
  <meta name="google-oauth-client-id"
        content="105230737516-l8tlnck4idde83pjetrotobpt8borvts.apps.googleusercontent.com" />
  <!-- SheetJS for Excel reading/writing – primary CDN -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
  <!-- Google Identity Services -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>

  <style>
    :root {
      --bg:#0f172a; --card:#020617; --panel:#020617; --border:#1e293b;
      --text:#e5e7eb; --muted:#94a3b8; --accent:#38bdf8; --accent-soft:rgba(56,189,248,0.12);
      --danger:#ef4444;
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg:#f8fafc; --card:#ffffff; --panel:#ffffff; --border:#e5e7eb;
        --text:#020617; --muted:#475569; --accent:#0ea5e9; --accent-soft:rgba(14,165,233,0.10);
        --danger:#b91c1c;
      }
    }
    * { box-sizing:border-box; }
    html, body { height:100%; }
    body {
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:
        radial-gradient(900px 600px at 5% 0%, rgba(56,189,248,0.10), transparent 55%),
        radial-gradient(800px 600px at 95% 0%, rgba(129,140,248,0.12), transparent 50%),
        var(--bg);
      color:var(--text);
    }
    .wrap {
      max-width: 1200px;
      margin:0 auto;
      padding:18px;
    }
    .card {
      background:var(--card);
      border-radius:20px;
      border:1px solid var(--border);
      padding:18px 18px 22px;
      box-shadow:0 18px 40px rgba(15,23,42,0.45);
      margin-bottom:16px;
    }
    h1 {
      margin:0 0 4px;
      font-size:26px;
      letter-spacing:.02em;
      display:flex;
      align-items:baseline;
      gap:8px;
      flex-wrap:wrap;
    }
    .version {
      font-size:11px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted);
    }
    .muted { color:var(--muted); font-size:14px; }
    .pill {
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size:11px;
      padding:3px 9px;
      border-radius:999px;
      border:1px solid var(--border);
      color:var(--muted);
      text-decoration:none;
      cursor:pointer;
    }
    .pill:hover {
      border-color:var(--accent);
      color:var(--accent);
      background:var(--accent-soft);
    }
    .section {
      margin-top:14px;
      padding:12px;
      border-radius:12px;
      background:rgba(15,23,42,0.65);
      border:1px dashed var(--border);
    }
    @media (prefers-color-scheme: light) {
      .section { background:#f9fafb; }
    }
    .section-title {
      font-size:13px;
      font-weight:700;
      text-transform:uppercase;
      letter-spacing:.08em;
      color:var(--muted);
      margin-bottom:6px;
    }
    label {
      font-size:13px;
      font-weight:600;
      margin-bottom:4px;
      display:block;
    }
    input, select, textarea {
      width:100%;
      font-size:14px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
    }
    textarea { resize:vertical; min-height:70px; }
    input::placeholder, textarea::placeholder { color:var(--muted); }
    .small-note { font-size:11px;color:var(--muted);margin-top:3px; }

    .grid {
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap:10px;
    }

    .btn-row { display:flex;flex-wrap:wrap;gap:8px;margin-top:8px; }
    button {
      border-radius:999px;
      border:1px solid var(--border);
      padding:8px 13px;
      font-size:14px;
      display:inline-flex;
      align-items:center;
      gap:6px;
      background:var(--panel);
      color:var(--text);
      cursor:pointer;
      transition:transform .06s ease, box-shadow .12s ease, background .12s ease, border-color .12s ease;
    }
    button.primary {
      border-color:var(--accent);
      background:linear-gradient(180deg,var(--accent-soft),transparent);
    }
    button:hover {
      transform:translateY(-1px);
      box-shadow:0 4px 12px rgba(15,23,42,0.5);
    }

    #status, #aiStatus {
      font-size:12px;color:var(--muted);margin-top:4px;
    }
    .danger { color:var(--danger); }

    details.transcript summary {
      cursor:pointer;
      font-size:13px;
      color:var(--muted);
      margin-bottom:4px;
    }
    .transcript-body {
      max-height:260px;
      overflow:auto;
      font-size:13px;
      line-height:1.5;
      border-radius:10px;
      border:1px solid var(--border);
      padding:8px;
      background:var(--panel);
      white-space:pre-wrap;
    }

    .summary-box {
      padding:8px;
      border-radius:10px;
      border:1px solid var(--border);
      background:var(--panel);
      font-size:13px;
      line-height:1.5;
      max-height:260px;
      overflow:auto;
    }
    .summary-box h2 {
      font-size:13px;
      margin:0 0 4px;
      text-transform:uppercase;
      letter-spacing:.06em;
      color:var(--muted);
    }
    ul { margin:4px 0 6px 18px;padding:0;font-size:13px; }
    li { margin-bottom:2px; }

    table {
      width:100%;
      border-collapse:collapse;
      font-size:12px;
    }
    th, td {
      border:1px solid var(--border);
      padding:4px 6px;
      vertical-align:top;
    }
    th {
      background:rgba(15,23,42,0.6);
      font-weight:600;
    }
    @media (prefers-color-scheme: light) {
      th { background:#e5e7eb; }
    }

    #productsTableWrapper, #proposalPreview {
      max-height:280px;
      overflow:auto;
      border-radius:10px;
      border:1px solid var(--border);
      padding:8px;
      background:var(--panel);
      font-size:13px;
      white-space:pre-wrap;
    }

    details.debug {
      margin-top:10px;
      border-radius:12px;
      border:1px dashed var(--border);
      padding:8px 10px;
      background:rgba(15,23,42,0.4);
      font-size:11px;
    }
    @media (prefers-color-scheme: light) {
      details.debug { background:#f3f4f6; }
    }
    details.debug summary {
      cursor:pointer;
      font-size:12px;
      color:var(--muted);
    }
    details.debug pre {
      white-space:pre-wrap;
      font-size:11px;
      margin-top:4px;
    }

    details.api {
      margin-top:10px;
      border-radius:12px;
      border:1px dashed var(--border);
      padding:6px 10px 10px;
      background:rgba(15,23,42,0.4);
      font-size:11px;
    }
    @media (prefers-color-scheme: light) {
      details.api { background:#f3f4f6; }
    }
    details.api summary {
      cursor:pointer;
      font-size:12px;
      color:var(--muted);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:10px;flex-wrap:wrap;">
        <div>
          <h1>
            Consultation Meeting Processor
            <span class="version">v0.5</span>
          </h1>
          <div class="muted">
            Pick a consultation event, upload the audio or a text transcript, get a transcript, structured summary,
            suggested kit from your spreadsheet template, and a proposal draft.
          </div>
        </div>
        <a href="https://frazerboorman.github.io/" class="pill">Frazer · AVD TOOLS</a>
      </div>

      <!-- STEP 1 – Calendar event -->
      <div class="section">
        <div class="section-title">Step 1 – Select consultation from Google Calendar</div>
        <div class="grid">
          <div>
            <label for="calendarId">Calendar ID</label>
            <input id="calendarId"
              value="bb14db72acb2ffd4230316960d02103fa66e54901522ff7b8113eec682f6d42e@group.calendar.google.com" />
            <div class="small-note">
              Same calendar you use in the other tools.
            </div>
          </div>
          <div>
            <label for="eventSelect">Recent events (last 14 days + today)</label>
            <select id="eventSelect">
              <option value="">Sign in to load events…</option>
            </select>
            <div id="status">Status: Waiting for sign-in…</div>
            <div id="aiStatus"></div>
          </div>
          <div style="align-self:end;">
            <button id="signinBtn" class="primary" type="button">Sign into Google</button>
            <div class="small-note">
              Same OAuth flow as the other tools.
            </div>
          </div>
        </div>
      </div>

      <!-- STEP 2 – Audio upload + processing -->
      <div class="section">
        <div class="section-title">Step 2 – Upload consultation audio &amp; process</div>
        <div class="grid">
          <div>
            <label for="audioFile">Consultation audio / text file</label>
            <input id="audioFile" type="file" accept="audio/*,text/plain" />
            <div class="small-note">
              Export from DJI Mic / Voice Memos first, or upload a .txt transcript. File only goes to OpenAI when transcribing.
            </div>
          </div>
        </div>

        <div class="btn-row">
          <button id="processBtn" class="primary" type="button">Process meeting (transcribe + summarise)</button>
        </div>
        <div class="small-note">
          Uses your OpenAI key stored in this browser (see “API key” panel below).
        </div>

        <div style="margin-top:10px;" class="grid">
          <div>
            <details class="transcript" id="transcriptDetails">
              <summary>Show full transcript</summary>
              <div class="transcript-body" id="transcriptBox">No transcript yet.</div>
            </details>
          </div>
          <div>
            <div class="summary-box">
              <h2>Consultation summary</h2>
              <div id="summaryBox">No summary yet.</div>
            </div>
          </div>
        </div>

        <div class="grid" style="margin-top:10px;">
          <div class="summary-box">
            <h2>Key issues</h2>
            <div id="issuesBox">–</div>
          </div>
          <div class="summary-box">
            <h2>Current equipment</h2>
            <div id="equipmentBox">–</div>
          </div>
        </div>

        <div class="summary-box" style="margin-top:10px;">
          <h2>Agreed / preferred solution</h2>
          <div id="solutionBox">–</div>
        </div>

        <details class="debug" style="margin-top:8px;">
          <summary>Debug view (structured AI JSON from transcript)</summary>
          <pre id="debugJson"></pre>
        </details>
      </div>

      <!-- STEP 3 – Spreadsheet template / product suggestions -->
      <div class="section">
        <div class="section-title">Step 3 – Suggest products from template spreadsheet</div>
        <div class="grid">
          <div>
            <label for="templateFile">Upload template spreadsheet (with “Products” sheet)</label>
            <input id="templateFile" type="file" accept=".xlsx,.xlsm,.xls" />
            <div class="small-note">
              This should be your master template. The tool reads the <strong>Products</strong> sheet,
              then writes selected rows into a new <strong>AutoSelected</strong> sheet rather than touching your formulas.
            </div>
          </div>
        </div>

        <div class="btn-row">
          <button id="generateProductsBtn" type="button">Generate product checklist (from summary + Products sheet)</button>
          <button id="downloadFilledTemplateBtn" type="button">Download workbook with AutoSelected</button>
        </div>

        <div class="small-note">
          Review the suggested products before you commit. Quantities &amp; notes come from the transcript where possible.
        </div>

        <div style="margin-top:10px;">
          <label>Suggested products (preview)</label>
          <div id="productsTableWrapper">No products suggested yet.</div>
        </div>
      </div>

      <!-- STEP 4 – Proposal generator -->
      <div class="section">
        <div class="section-title">Step 4 – Proposal generator (from priced spreadsheet)</div>
        <div class="grid">
          <div>
            <label for="pricedFile">Upload edited/priced spreadsheet</label>
            <input id="pricedFile" type="file" accept=".xlsx,.xlsm,.xls" />
            <div class="small-note">
              Use the template you’ve filled with prices, labour, totals etc.
              The tool will read the <strong>Clean</strong> sheet if present, otherwise the first sheet.
            </div>
          </div>
        </div>

        <div class="btn-row">
          <button id="generateProposalBtn" type="button" class="primary">Generate proposal / quote</button>
          <button id="downloadProposalDocBtn" type="button">Download proposal as Word (.doc)</button>
        </div>

        <div style="margin-top:10px;">
          <label>Proposal preview</label>
          <div id="proposalPreview">No proposal generated yet.</div>
        </div>
      </div>
    </div>

    <!-- API KEY PANEL -->
    <details class="api">
      <summary>API key (OpenAI) – hidden by default</summary>
      <div class="small-note" style="margin-top:4px;">
        Stored locally in <code>localStorage['avd_job_report_openai_key']</code>. Never sent anywhere except OpenAI’s API.
      </div>
      <div style="display:flex;gap:6px;align-items:center;margin-top:6px;flex-wrap:wrap;">
        <input id="apiKeyInput" type="password" placeholder="sk-..." style="flex:1 1 220px;max-width:380px;">
        <button type="button" id="saveApiKeyBtn">Save</button>
        <button type="button" id="clearApiKeyBtn">Forget</button>
      </div>
      <div id="apiKeyStatus" class="small-note"></div>
    </details>

    <!-- Global debug panel -->
    <details class="debug">
      <summary>Debug panel</summary>
      <pre id="debugLog">(empty)</pre>
    </details>

    <!-- AI Debugger panel -->
    <details class="debug">
      <summary>AI Debugger</summary>
      <div class="small-note" style="margin-top:4px;">
        Uses your OpenAI API key and the v5.1 model to analyse this tool’s index.html, debug log, and console errors.
        It follows your “Be Strict” rules and either proposes a replacement index.html or a prompt you can paste into ChatGPT.
      </div>
      <div class="small-note" style="margin-top:6px;">
        Optional notes for the debugger (what you were doing, what broke):
      </div>
      <textarea id="aiDebugNotes" style="width:100%;min-height:70px;margin-top:4px;"></textarea>
      <div class="btn-row" style="margin-top:6px;">
        <button type="button" id="runAiDebugBtn">Run AI Debugger (5.1)</button>
      </div>
      <div id="aiDebugStatus" class="small-note" style="margin-top:4px;"></div>
      <div class="small-note" style="margin-top:6px;">
        AI assessment (issues found, reasons, planned fixes):
      </div>
      <pre id="aiDebugExplanation"></pre>
      <div class="small-note" style="margin-top:6px;">
        Captured console errors (auto-collected):
      </div>
      <pre id="consoleErrorLog"></pre>
    </details>

    <!-- Replacement Index panel -->
    <details class="debug">
      <summary>Replacement index.html from AI Debugger</summary>
      <div class="small-note" style="margin-top:4px;">
        When AI Debugger provides a new index, it appears here. Copy this into your editor if you accept the changes.
      </div>
      <textarea id="aiDebugReplacementIndex" style="width:100%;min-height:200px;margin-top:6px;white-space:pre;"></textarea>
    </details>
  </div>

  <script>
    // =========================
    // CONFIG / SHARED CONSTANTS
    // =========================
    const CLIENT_ID = "105230737516-l8tlnck4idde83pjetrotobpt8borvts.apps.googleusercontent.com";
    const SCOPES   = "https://www.googleapis.com/auth/calendar.readonly";
    const OPENAI_KEY_STORAGE = "avd_job_report_openai_key";
    const TEXT_MODEL = "gpt-4.1-mini";
    const AUDIO_MODEL = "whisper-1";
    const DEBUG_MODEL = "gpt-5.1";

    let tokenClient = null;
    let accessToken = null;
    let currentEvents = [];
    let lastTranscript = "";
    let lastStructuredSummary = null;
    let lastProductSelection = null;
    let lastProposalText = "";

    // ==============
    // DEBUG LOGGER
    // ==============
    function logDebug(msg) {
      try {
        const el = document.getElementById("debugLog");
        if (!el) return;
        const ts = new Date().toISOString().replace("T"," ").slice(0,19);
        el.textContent += "[" + ts + "] " + msg + "\n";
        el.scrollTop = el.scrollHeight;
      } catch (e) {
        if (console && console.warn) console.warn("debugLog error", e);
      }
    }

    // =========================
    // CONSOLE ERROR CAPTURE
    // =========================
    const capturedConsoleErrors = [];

    function appendConsoleError(msg) {
      const ts = new Date().toISOString().replace("T"," ").slice(0,19);
      const line = "[" + ts + "] " + msg;
      capturedConsoleErrors.push(line);
      try {
        const pre = document.getElementById("consoleErrorLog");
        if (pre) {
          pre.textContent = capturedConsoleErrors.join("\n");
        }
      } catch (e) {
        // ignore UI update errors
      }
      logDebug("CONSOLE ERROR: " + msg);
    }

    (function hookConsoleForErrors() {
      try {
        const originalError = console.error ? console.error.bind(console) : null;
        console.error = function() {
          try {
            const msg = Array.from(arguments).map(a => String(a)).join(" ");
            appendConsoleError(msg);
          } catch (e) {
            // ignore
          }
          if (originalError) {
            originalError.apply(console, arguments);
          }
        };
      } catch (e) {
        // ignore hooking errors
      }

      window.addEventListener("error", (event) => {
        try {
          const msg = event && event.message ? event.message : String(event.error || "Unknown error");
          appendConsoleError("window.error: " + msg);
        } catch (e2) {
          // ignore
        }
      });

      window.addEventListener("unhandledrejection", (event) => {
        try {
          const reason = event && event.reason ? event.reason : "Unknown rejection";
          const msg = typeof reason === "string"
            ? reason
            : (reason && reason.message) ? reason.message : String(reason);
          appendConsoleError("unhandledrejection: " + msg);
        } catch (e2) {
          // ignore
        }
      });
    })();



    // ==============
    // STATUS HELPERS
    // ==============
    function setStatus(msg, isError) {
      const el = document.getElementById("status");
      if (!el) return;
      el.textContent = "Status: " + msg;
      el.className = isError ? "danger" : "";
      logDebug("STATUS: " + msg);
    }

    function setAiStatus(msg, isError) {
      const el = document.getElementById("aiStatus");
      if (!el) return;
      el.textContent = msg || "";
      el.className = isError ? "danger" : "";
      if (msg) logDebug("AI: " + msg);
    }

    function escapeHtml(str) {
      return String(str || "")
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;");
    }

    // ======================
    // GOOGLE AUTH & CALENDAR
    // ======================
    function getEventStartDate(ev) {
      if (!ev || !ev.start) return null;
      if (ev.start.date) return new Date(ev.start.date + "T00:00:00Z");
      if (ev.start.dateTime) return new Date(ev.start.dateTime);
      return null;
    }
    function extractEventDate(ev) {
      if (!ev || !ev.start) return "";
      if (ev.start.date) return ev.start.date;
      if (ev.start.dateTime) return ev.start.dateTime.slice(0,10);
      return "";
    }

    function initAuth() {
      if (!window.google || !google.accounts || !google.accounts.oauth2) {
        logDebug("Google auth library not ready yet.");
        return;
      }
      tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: SCOPES,
        prompt: "",
        callback: (resp) => {
          if (resp && resp.access_token) {
            accessToken = resp.access_token;
            setStatus("Signed in. Loading events…", false);
            loadRecentEvents();
          } else {
            setStatus("Sign-in failed.", true);
          }
        }
      });
      logDebug("Google tokenClient initialised.");
    }

    function signInManual() {
      if (!tokenClient) initAuth();
      if (!tokenClient) {
        setStatus("Google auth not ready.", true);
        return;
      }
      logDebug("Requesting Google access token…");
      tokenClient.requestAccessToken();
    }

    async function loadRecentEvents() {
      if (!accessToken) {
        setStatus("No access token yet.", true);
        return;
      }
      const calId = (document.getElementById("calendarId").value || "primary").trim();

      const now = new Date();
      const end = new Date(now);
      end.setHours(23,59,59,999);
      const start = new Date(now);
      start.setDate(start.getDate() - 14);
      start.setHours(0,0,0,0);

      const url = new URL(
        "https://www.googleapis.com/calendar/v3/calendars/" +
        encodeURIComponent(calId) +
        "/events"
      );
      url.searchParams.set("singleEvents","true");
      url.searchParams.set("orderBy","startTime");
      url.searchParams.set("timeMin", start.toISOString());
      url.searchParams.set("timeMax", end.toISOString());
      url.searchParams.set("maxResults","250");

      logDebug("Fetching events: " + url.toString());

      const res = await fetch(url.toString(), {
        headers: { "Authorization":"Bearer " + accessToken }
      });
      if (!res.ok) {
        setStatus("Calendar API error " + res.status, true);
        return;
      }
      const data = await res.json();
      const items = data.items || [];
      const nowRef = new Date();

      const processed = items
        .map(ev => ({ ev, startDate: getEventStartDate(ev) }))
        .filter(obj => obj.startDate && obj.startDate <= nowRef)
        .sort((a,b) => b.startDate - a.startDate);

      currentEvents = processed.map(x => x.ev);

      const sel = document.getElementById("eventSelect");
      sel.innerHTML = "";
      if (!currentEvents.length) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "No events in last 14 days.";
        sel.appendChild(opt);
        setStatus("No recent events found.", false);
        return;
      }

      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = "— Select consultation —";
      sel.appendChild(placeholder);

      currentEvents.forEach((ev, idx) => {
        const title = ev.summary || "(no title)";
        const d = extractEventDate(ev);
        const opt = document.createElement("option");
        opt.value = String(idx);
        opt.textContent = (d ? (d + " – ") : "") + title;
        sel.appendChild(opt);
      });

      setStatus("Loaded " + currentEvents.length + " events.", false);
      logDebug("Loaded " + currentEvents.length + " events.");
    }

    // ===================
    // OPENAI: AUDIO + NLP
    // ===================
    function getOpenAIKeyOrThrow() {
      const key = localStorage.getItem(OPENAI_KEY_STORAGE);
      if (!key) {
        throw new Error("No OpenAI API key found. Set it in the API key panel.");
      }
      return key;
    }

    async function transcribeAudio(file) {
      const apiKey = getOpenAIKeyOrThrow();

      // Text file path
      if (file.type === "text/plain" || file.name.toLowerCase().endsWith(".txt")) {
        logDebug("Treating file as plain text transcript: " + file.name);
        const text = await file.text();
        return text || "";
      }

      const formData = new FormData();
      formData.append("file", file);
      formData.append("model", AUDIO_MODEL);
      formData.append("response_format","json");

      logDebug("Sending audio to OpenAI whisper…");

      const res = await fetch("https://api.openai.com/v1/audio/transcriptions", {
        method: "POST",
        headers: {
          "Authorization": "Bearer " + apiKey
        },
        body: formData
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error("Audio transcription error " + res.status + ": " + txt);
      }
      const data = await res.json();
      return data.text || "";
    }

    async function summariseTranscript(transcript, eventMeta) {
      const apiKey = getOpenAIKeyOrThrow();
      const systemPrompt =
        "You are processing a recorded AV consultation meeting between an engineer and client.\n" +
        "You receive the full transcript as plain text and some optional calendar event metadata.\n\n" +
        "GOALS:\n" +
        "1) Produce a concise consultation summary for the engineer, not the client.\n" +
        "2) Identify key issues the client is facing (bullet points).\n" +
        "3) Identify current equipment and, where stated, whether it works, is failing, or is unknown.\n" +
        "4) Identify the final agreed / preferred solution, not just options that were discussed and rejected.\n" +
        "5) Produce a 'productNeeds' list the system can use later to pick products from a spreadsheet.\n\n" +
        "Rules:\n" +
        "- Read the ENTIRE transcript before deciding what was actually agreed.\n" +
        "- If something was clearly rejected, do NOT list it as part of the final solution.\n" +
        "- Do NOT invent any kit or decisions that are not in the transcript.\n" +
        "- productNeeds items should be high-level roles like 'ceiling speakers for main hall', '4K projector',\n" +
        "  'HDMI wall plate', 'wireless handheld microphone', etc.\n\n" +
        "Return STRICT JSON ONLY in this format:\n" +
        "{\n" +
        '  \"summary\": \"Short paragraph summarising the meeting from the engineer’s perspective.\",\n' +
        '  \"keyIssues\": [\"issue 1\", \"issue 2\", \"...\"],\n' +
        '  \"currentEquipment\": [\n' +
        '    { \"name\": \"\", \"status\": \"working | failing | unknown\", \"notes\": \"\" }\n' +
        '  ],\n' +
        '  \"agreedSolution\": \"Paragraph describing final agreed solution.\",\n' +
        '  \"productNeeds\": [\n' +
        '    {\n' +
        '      \"categoryHint\": \"Audio | Visual | Control | Streaming | Infrastructure | Other\",\n' +
        '      \"role\": \"e.g. ceiling speakers, projector, wall plate, amp, etc.\",\n' +
        '      \"quantity\": 0,\n' +
        '      \"extraNotes\": \"any constraints mentioned (e.g. white finish, left wall, balcony, etc.)\"\n' +
        '    }\n' +
        '  ]\n' +
        "}\n" +
        "No explanatory text outside the JSON.";

      const payload = { transcript, eventMeta };

      logDebug("Sending transcript to OpenAI for structured summary…");

      const res = await fetch("https://api.openai.com/v1/responses", {
        method: "POST",
        headers: {
          "Content-Type":"application/json",
          "Authorization":"Bearer " + apiKey
        },
        body: JSON.stringify({
          model: TEXT_MODEL,
          input: [
            { role:"system", content: systemPrompt },
            { role:"user", content: JSON.stringify(payload) }
          ]
        })
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error("Summary AI error " + res.status + ": " + txt);
      }
      const data = await res.json();
      let rawText = "";
      if (
        data.output &&
        data.output[0] &&
        data.output[0].content &&
        data.output[0].content[0] &&
        data.output[0].content[0].text
      ) {
        rawText = data.output[0].content[0].text;
      } else {
        throw new Error("Unexpected AI summary response shape.");
      }

      let parsed;
      try {
        parsed = JSON.parse(rawText);
      } catch (e) {
        console.error("Failed to parse AI JSON:", rawText);
        throw new Error("Failed to parse AI JSON summary.");
      }
      logDebug("Structured summary parsed.");
      return parsed;
    }

    async function handleProcessMeeting() {
      const fileInput = document.getElementById("audioFile");
      const file = fileInput.files && fileInput.files[0];
      if (!file) {
        setAiStatus("Please choose an audio or text file first.", true);
        return;
      }

      document.getElementById("processBtn").disabled = true;
      setAiStatus("Uploading and transcribing / reading…", false);
      logDebug("Processing file: " + file.name + " (" + file.type + ", " + file.size + " bytes)");

      try {
        const eventSel = document.getElementById("eventSelect");
        let eventMeta = null;
        if (eventSel.value) {
          const ev = currentEvents[Number(eventSel.value)];
          if (ev) {
            eventMeta = {
              title: ev.summary || "",
              description: ev.description || "",
              location: ev.location || "",
              start: ev.start || {}
            };
          }
        }

        const transcript = await transcribeAudio(file);
        lastTranscript = transcript || "";

        document.getElementById("transcriptBox").textContent =
          transcript ? transcript : "Transcription / text returned empty.";

        setAiStatus("Transcribed / loaded. Summarising and structuring…", false);

        const structured = await summariseTranscript(transcript, eventMeta);
        lastStructuredSummary = structured;

        // Render into UI
        document.getElementById("summaryBox").innerHTML =
          structured.summary
            ? escapeHtml(structured.summary).replace(/\n/g,"<br>")
            : "No summary returned.";

        if (Array.isArray(structured.keyIssues) && structured.keyIssues.length) {
          document.getElementById("issuesBox").innerHTML =
            "<ul>" + structured.keyIssues
              .map(i => "<li>" + escapeHtml(i) + "</li>")
              .join("") + "</ul>";
        } else {
          document.getElementById("issuesBox").textContent = "No key issues extracted.";
        }

        if (Array.isArray(structured.currentEquipment) && structured.currentEquipment.length) {
          const lis = structured.currentEquipment.map(eq => {
            const name = eq.name || "-";
            const status = eq.status || "unknown";
            const notes = eq.notes || "";
            let line = "<strong>" + escapeHtml(name) + "</strong> (" + escapeHtml(status) + ")";
            if (notes) line += " – " + escapeHtml(notes);
            return "<li>" + line + "</li>";
          }).join("");
          document.getElementById("equipmentBox").innerHTML = "<ul>" + lis + "</ul>";
        } else {
          document.getElementById("equipmentBox").textContent = "No equipment explicitly mentioned.";
        }

        document.getElementById("solutionBox").innerHTML =
          structured.agreedSolution
            ? escapeHtml(structured.agreedSolution).replace(/\n/g,"<br>")
            : "No final solution clearly extracted.";

        document.getElementById("debugJson").textContent =
          JSON.stringify(structured, null, 2);

        setAiStatus("Transcript and summary ready. Review summary before product selection.", false);
      } catch (e) {
        console.error(e);
        setAiStatus(e.message || "Error processing meeting.", true);
      } finally {
        document.getElementById("processBtn").disabled = false;
      }
    }

    // ===========================
    // STEP 3: PRODUCTS / TEMPLATE
    // ===========================
    async function handleGenerateProducts() {
      if (!lastStructuredSummary) {
        setAiStatus("Process the meeting first to get a structured summary.", true);
        return;
      }
      if (typeof XLSX === "undefined") {
        setAiStatus("Spreadsheet library (XLSX) is not available – wait a moment and try again.", true);
        logDebug("handleGenerateProducts: XLSX is undefined.");
        return;
      }

      const fileInput = document.getElementById("templateFile");
      const file = fileInput.files && fileInput.files[0];
      if (!file) {
        setAiStatus("Upload your template spreadsheet (with Products sheet) first.", true);
        return;
      }

      setAiStatus("Reading template & sending to AI for product selection…", false);
      document.getElementById("generateProductsBtn").disabled = true;

      try {
        const arrayBuffer = await file.arrayBuffer();
        const wb = XLSX.read(arrayBuffer, { type:"array" });

        const productsSheet = wb.Sheets["Products"];
        if (!productsSheet) {
          throw new Error("No 'Products' sheet found in template.");
        }

        const rows = XLSX.utils.sheet_to_json(productsSheet, { header:1 });
        if (!rows.length) {
          throw new Error("Products sheet is empty.");
        }

        const headers = rows[0];
        const dataRows = rows.slice(1);

        const productTableForAI = dataRows.map((row, idx) => {
          const obj = { rowIndex: idx + 2 };
          headers.forEach((h, colIdx) => {
            if (!h) return;
            obj[String(h)] = row[colIdx];
          });
          return obj;
        });

        const apiKey = getOpenAIKeyOrThrow();
        const systemPrompt =
          "You are helping choose products from an AV company's master 'Products' sheet.\n" +
          "You receive:\n" +
          "- A structured consultation summary with productNeeds.\n" +
          "- A list of products from the 'Products' sheet, with their columns exactly as given.\n\n" +
          "Your job:\n" +
          "- For each product need, choose the most appropriate product(s) from the list.\n" +
          "- Decide which checklist the product should appear in: 'Audio', 'Visual', 'Control', 'Streaming', 'Infrastructure', or 'Other'.\n" +
          "- Suggest a quantity (0 if you really cannot tell, but try to infer from the needs).\n" +
          "- Add a short notes field with key details (e.g. 'Combi JTS RX – 1 HH + 1 belt-pack', 'White finish', 'Left wall mount', etc.).\n\n" +
          "Rules:\n" +
          "- Do NOT invent product names not present in the products table.\n" +
          "- You may choose multiple products for a single need if sensible (e.g. projector + mount + wallplate).\n" +
          "- If the products sheet has a column that clearly indicates its natural checklist (e.g. 'Category'), use it.\n" +
          "- If multiple products fit, choose the most likely / standard option.\n\n" +
          "Return STRICT JSON ONLY in this format:\n" +
          "{\n" +
          '  \"items\": [\n' +
          "    {\n" +
          '      \"rowIndex\": 0,\n' +
          '      \"checklist\": \"Audio | Visual | Control | Streaming | Infrastructure | Other\",\n' +
          '      \"quantity\": 0,\n' +
          '      \"notes\": \"short engineer-facing note\",\n' +
          '      \"reason\": \"why this product was chosen (brief)\",\n' +
          '      \"productSnapshot\": { }\n' +
          "    }\n" +
          "  ]\n" +
          "}\n" +
          "No explanatory text outside the JSON.";

        const payload = {
          structuredSummary: lastStructuredSummary,
          products: productTableForAI
        };

        const res = await fetch("https://api.openai.com/v1/responses", {
          method:"POST",
          headers:{
            "Content-Type":"application/json",
            "Authorization":"Bearer " + apiKey
          },
          body: JSON.stringify({
            model: TEXT_MODEL,
            input: [
              { role:"system", content: systemPrompt },
              { role:"user", content: JSON.stringify(payload) }
            ]
          })
        });
        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error("Product selection AI error " + res.status + ": " + txt);
        }
        const data = await res.json();
        let rawText = "";
        if (
          data.output &&
          data.output[0] &&
          data.output[0].content &&
          data.output[0].content[0] &&
          data.output[0].content[0].text
        ) {
          rawText = data.output[0].content[0].text;
        } else {
          throw new Error("Unexpected product AI response shape.");
        }

        let parsed;
        try {
          parsed = JSON.parse(rawText);
        } catch (e) {
          console.error("Product AI JSON parse failed:", rawText);
          throw new Error("Could not parse JSON from product AI.");
        }

        lastProductSelection = {
          workbook: wb,
          headers,
          rows,
          selection: parsed.items || []
        };

        renderProductSelectionTable(lastProductSelection);
        setAiStatus("Product suggestions generated. Review before downloading workbook.", false);
      } catch (e) {
        console.error(e);
        setAiStatus(e.message || "Error generating product suggestions.", true);
      } finally {
        document.getElementById("generateProductsBtn").disabled = false;
      }
    }

    function renderProductSelectionTable(state) {
      const wrap = document.getElementById("productsTableWrapper");
      if (!state || !state.selection || !state.selection.length) {
        wrap.textContent = "No products suggested.";
        return;
      }
      const rowsHtml = state.selection.map(item => {
        const rowIdx = item.rowIndex;
        const checklist = item.checklist || "";
        const qty = item.quantity != null ? String(item.quantity) : "";
        const notes = item.notes || "";
        const reason = item.reason || "";
        const snapshot = item.productSnapshot || {};
        const name = snapshot.Name || snapshot.name || snapshot.Product || "";
        return "<tr>" +
          "<td>" + escapeHtml(checklist) + "</td>" +
          "<td>" + escapeHtml(String(qty)) + "</td>" +
          "<td>" + escapeHtml(name || "[from row " + rowIdx + "]") + "</td>" +
          "<td>" + escapeHtml(notes) + "</td>" +
          "<td>" + escapeHtml(reason) + "</td>" +
        "</tr>";
      }).join("");

      wrap.innerHTML =
        "<table>" +
          "<thead><tr>" +
            "<th>Checklist</th>" +
            "<th>Qty</th>" +
            "<th>Product</th>" +
            "<th>Notes</th>" +
            "<th>Why chosen</th>" +
          "</tr></thead>" +
          "<tbody>" + rowsHtml + "</tbody>" +
        "</table>";
    }

    function handleDownloadFilledTemplate() {
      if (!lastProductSelection) {
        alert("Generate product suggestions first.");
        return;
      }
      const { workbook, selection } = lastProductSelection;
      const data = selection || [];
      if (!data.length) {
        alert("No suggested products to write.");
        return;
      }
      if (typeof XLSX === "undefined") {
        alert("Spreadsheet library (XLSX) is not available.");
        return;
      }

      const header = ["Checklist","Qty","RowIndex","Notes","Reason","ProductSnapshot"];
      const rows = [header];
      data.forEach(item => {
        rows.push([
          item.checklist || "",
          item.quantity != null ? item.quantity : "",
          item.rowIndex != null ? item.rowIndex : "",
          item.notes || "",
          item.reason || "",
          JSON.stringify(item.productSnapshot || {})
        ]);
      });
      const ws = XLSX.utils.aoa_to_sheet(rows);
      workbook.Sheets["AutoSelected"] = ws;
      if (!workbook.SheetNames.includes("AutoSelected")) {
        workbook.SheetNames.push("AutoSelected");
      }

      const wbout = XLSX.write(workbook, { bookType:"xlsx", type:"array" });
      const blob = new Blob([wbout], { type:"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "template_with_autoselected.xlsx";
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
      }, 0);
    }

    // ======================
    // STEP 4: PROPOSAL / QUOTE
    // ======================
    async function handleGenerateProposal() {
      const pricedInput = document.getElementById("pricedFile");
      const file = pricedInput.files && pricedInput.files[0];
      if (!file) {
        setAiStatus("Upload your priced spreadsheet first.", true);
        return;
      }
      if (typeof XLSX === "undefined") {
        setAiStatus("Spreadsheet library (XLSX) is not available.", true);
        return;
      }

      document.getElementById("generateProposalBtn").disabled = true;
      setAiStatus("Reading priced sheet & generating proposal…", false);

      try {
        const arrayBuffer = await file.arrayBuffer();
        const wb = XLSX.read(arrayBuffer, { type:"array" });

        let sheetName = "Clean";
        if (!wb.Sheets[sheetName]) {
          sheetName = wb.SheetNames[0];
        }
        const sheet = wb.Sheets[sheetName];
        if (!sheet) throw new Error("No usable sheet found in priced workbook.");
        const table = XLSX.utils.sheet_to_json(sheet, { header:1 });

        const apiKey = getOpenAIKeyOrThrow();
        const systemPrompt =
          "You are generating a client-facing AV proposal/quote based on a priced spreadsheet and a consultation summary.\n\n" +
          "You will receive:\n" +
          "- A structured consultation summary (issues, current equipment, agreed solution).\n" +
          "- A table from the 'Clean' (or equivalent) sheet of a spreadsheet that includes products, prices, quantities, totals, and possibly labour/time.\n\n" +
          "Your job:\n" +
          "1) Identify the main components that should be described in the proposal (projectors, screens/TVs, main speakers, amps, microphones, key control hardware, streaming hardware etc.).\n" +
          "   Do NOT write paragraphs about minor items (mounts, brackets, small accessories).\n" +
          "2) For each main component, write a short, clear description referencing relevant details from the consultation summary\n" +
          "   (e.g. mounting position like 'left wall', use-cases like film nights, speech clarity, etc.).\n" +
          "3) Group costs sensibly (e.g. Audio, Visual, Control, Infrastructure, Labour) and show totals per group plus a grand total.\n" +
          "4) Mention estimated days on site, based on any labour/time information in the table (if present). If there is genuinely no\n" +
          "   indication of labour/time, say 'Installation duration to be confirmed'.\n" +
          "5) Write this as a proposal/quote that could be sent to the client, in clear UK English.\n\n" +
          "Rules:\n" +
          "- Do NOT invent extra products or prices. Work only from the spreadsheet table.\n" +
          "- You may infer reasonable grouping from column headers (e.g. 'Category', 'Checklist', etc.).\n" +
          "- Do NOT expose raw spreadsheet table in the body, but you can refer to product names.\n\n" +
          "Structure the output as:\n" +
          "1) Short opening paragraph referencing the client's situation.\n" +
          "2) Bullet list of key benefits of the proposed solution.\n" +
          "3) Headings for each main area (Audio System, Visual System, Control/Operation, Streaming/Broadcast, Infrastructure & Cabling, Labour & Timescales).\n" +
          "4) Under each heading, short paragraphs describing what is included.\n" +
          "5) Section with pricing breakdown per area and overall total.\n" +
          "6) Closing paragraph about next steps.\n";

        const payload = {
          structuredSummary: lastStructuredSummary,
          pricedSheetName: sheetName,
          pricedTable: table
        };

        const res = await fetch("https://api.openai.com/v1/responses", {
          method:"POST",
          headers:{
            "Content-Type":"application/json",
            "Authorization":"Bearer " + apiKey
          },
          body: JSON.stringify({
            model: TEXT_MODEL,
            input: [
              { role:"system", content: systemPrompt },
              { role:"user", content: JSON.stringify(payload) }
            ]
          })
        });

        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          throw new Error("Proposal AI error " + res.status + ": " + txt);
        }
        const data = await res.json();
        let text = "";
        if (
          data.output &&
          data.output[0] &&
          data.output[0].content &&
          data.output[0].content[0] &&
          data.output[0].content[0].text
        ) {
          text = data.output[0].content[0].text;
        } else {
          throw new Error("Unexpected proposal response shape.");
        }

        lastProposalText = text;
        document.getElementById("proposalPreview").textContent = text;
        setAiStatus("Proposal generated. Review and tweak as needed.", false);
      } catch (e) {
        console.error(e);
        setAiStatus(e.message || "Error generating proposal.", true);
      } finally {
        document.getElementById("generateProposalBtn").disabled = false;
      }
    }

    function handleDownloadProposalDoc() {
      if (!lastProposalText) {
        alert("Generate a proposal first.");
        return;
      }
      const html =
        "<!doctype html><html><head><meta charset='utf-8'>" +
        "<title>Proposal</title>" +
        "<style>" +
        "body{font-family:Calibri,Arial,sans-serif;font-size:11pt;color:#000;}"+
        "h1,h2,h3{font-weight:bold;}"+
        "</style></head><body>" +
        "<pre style='white-space:pre-wrap;font-family:Calibri,Arial,sans-serif;'>" +
        escapeHtml(lastProposalText) +
        "</pre></body></html>";

      const blob = new Blob([html], { type:"application/msword" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "proposal.doc";
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
      }, 0);
    }

    // ====================
    // API KEY PANEL LOGIC
    // ====================
    function refreshApiKeyStatus() {
      const statusEl = document.getElementById("apiKeyStatus");
      const key = localStorage.getItem(OPENAI_KEY_STORAGE);
      if (key) {
        statusEl.textContent = "API key is stored in this browser.";
      } else {
        statusEl.textContent = "No API key stored yet.";
      }
    }

    function handleSaveApiKey() {
      const input = document.getElementById("apiKeyInput");
      const v = (input.value || "").trim();
      if (!v) {
        alert("Enter a key first.");
        return;
      }
      localStorage.setItem(OPENAI_KEY_STORAGE, v);
      input.value = "";
      refreshApiKeyStatus();
      logDebug("OpenAI key saved to localStorage.");
    }

    function handleClearApiKey() {
      localStorage.removeItem(OPENAI_KEY_STORAGE);
      refreshApiKeyStatus();
      logDebug("OpenAI key cleared from localStorage.");
    }

    // ======================
    // AI DEBUGGER (5.1, "Be Strict")
    // ======================
    async function handleRunAiDebug() {
      const statusEl = document.getElementById("aiDebugStatus");
      const explanationEl = document.getElementById("aiDebugExplanation");
      const replacementEl = document.getElementById("aiDebugReplacementIndex");

      if (statusEl) statusEl.textContent = "";
      if (explanationEl) explanationEl.textContent = "";
      if (replacementEl) replacementEl.value = "";

      let apiKey;
      try {
        apiKey = getOpenAIKeyOrThrow();
      } catch (e) {
        if (statusEl) {
          statusEl.textContent = e.message || "No OpenAI API key found.";
          statusEl.className = "small-note danger";
        }
        logDebug("AI Debugger aborted: " + (e.message || e));
        return;
      }

      const debugLogEl = document.getElementById("debugLog");
      const notesEl = document.getElementById("aiDebugNotes");

      const payload = {
        indexHtml: document.documentElement ? document.documentElement.outerHTML : "",
        debugLog: debugLogEl ? debugLogEl.textContent || "" : "",
        consoleErrors: capturedConsoleErrors.slice(),
        userNotes: notesEl ? (notesEl.value || "") : ""
      };

      const systemPrompt =
        "You are an expert web engineer and tooling specialist helping maintain a single-page HTML/JS tool called the 'Consultation Meeting Processor'.\n" +
        "The page is a self-contained index.html file with inline CSS and JavaScript. It does the following:\n" +
        "- Uses Google Calendar (OAuth2) to load recent consultation events.\n" +
        "- Lets the user upload audio or text transcripts and calls OpenAI Whisper to transcribe when needed.\n" +
        "- Uses OpenAI text models to: (1) structure the consultation summary; (2) select products from a 'Products' sheet; (3) generate a client-facing proposal.\n" +
        "- Includes a debug log panel, and an AI Debugger panel that sends the entire index.html, debug log and console errors to you.\n\n" +
        "You MUST follow the user's 'Be Strict' rules when proposing code fixes:\n" +
        "1) Treat the provided indexHtml as the single source of truth.\n" +
        "2) Only change code that is directly necessary to:\n" +
        "   - Fix clear bugs / runtime errors.\n" +
        "   - Wire up or repair the AI Debugger itself.\n" +
        "   - Keep the file syntactically valid.\n" +
        "3) Do NOT refactor, rename, or reformat unrelated code.\n" +
        "4) Preserve the structure, layout, and indentation as much as possible.\n" +
        "5) When you return a new index.html, it MUST be complete and non-truncated, starting with <!doctype html> and ending with </html>.\n" +
        "6) When you generate a replacement index.html, bump the version pill in the <span class=\"version\"> element by a small step (e.g. v0.5 -> v0.6).\n" +
        "7) If the issue cannot be solved purely by editing this index.html (e.g. external API keys, CORS, account configuration), you MUST NOT guess fixes in code. Instead, you will prepare a clear 'externalHelpPrompt' text the user can paste into ChatGPT for deeper discussion.\n\n" +
        "You are given:\n" +
        "- indexHtml: the full current HTML of the page.\n" +
        "- debugLog: the tool's internal debug log.\n" +
        "- consoleErrors: errors captured from the browser console.\n" +
        "- userNotes: any extra notes the engineer added.\n\n" +
        "Your job:\n" +
        "1) Carefully inspect indexHtml, debugLog, consoleErrors, and userNotes to identify likely causes of failure.\n" +
        "2) Decide if the problem can reasonably be fixed by editing indexHtml alone.\n" +
        "3) If yes:\n" +
        "   - Prepare a concise description of the issues and fixes.\n" +
        "   - Produce a SINGLE replacement index.html string that incorporates only the necessary changes, obeying the 'Be Strict' rules.\n" +
        "   - Ensure the result is syntactically valid HTML/JS and preserves all existing behaviour unless you are deliberately fixing a bug.\n" +
        "4) If no (e.g. missing API key, external configuration, environment/network issue):\n" +
        "   - Do NOT fabricate code fixes.\n" +
        "   - Instead, prepare a clear prompt the user can paste into ChatGPT, summarising what you see and what they should investigate.\n\n" +
        "Output STRICT JSON ONLY in this schema (no extra commentary):\n" +
        "{\n" +
        "  \"mode\": \"replacement_index\" | \"external_help\",\n" +
        "  \"issuesSummary\": \"Short high-level summary of what seems wrong.\",\n" +
        "  \"details\": [\n" +
        "    {\n" +
        "      \"issue\": \"What is wrong.\",\n" +
        "      \"likelyCause\": \"Why it is happening.\",\n" +
        "      \"fix\": \"What change you plan to make or why it cannot be fixed in code.\",\n" +
        "      \"changedArea\": \"Which part of the file this concerns (e.g. Google auth, Whisper, AI Debugger, Spreadsheet, Proposal).\"\n" +
        "    }\n" +
        "  ],\n" +
        "  \"newIndexHtml\": \"<!doctype html>...full replacement index.html...\",\n" +
        "  \"externalHelpPrompt\": \"If mode is external_help, a ready-made prompt the user can paste into ChatGPT describing the issue in detail.\"\n" +
        "}\n" +
        "If mode is \"replacement_index\", you MUST provide a complete non-truncated newIndexHtml and may leave externalHelpPrompt empty.\n" +
        "If mode is \"external_help\", you MUST provide a strong externalHelpPrompt and may leave newIndexHtml empty or omitted.\n";

      if (statusEl) {
        statusEl.textContent = "Running AI Debugger with v5.1…";
        statusEl.className = "small-note";
      }
      logDebug("AI Debugger: sending indexHtml, debugLog, and consoleErrors to OpenAI 5.1…");

      try {
        const res = await fetch("https://api.openai.com/v1/responses", {
          method: "POST",
          headers: {
            "Content-Type":"application/json",
            "Authorization":"Bearer " + apiKey
          },
          body: JSON.stringify({
            model: DEBUG_MODEL,
            input: [
              { role:"system", content: systemPrompt },
              { role:"user", content: JSON.stringify(payload) }
            ]
          })
        });

        if (!res.ok) {
          const txt = await res.text().catch(() => "");
          const msg = "AI Debugger error " + res.status + ": " + txt;
          appendConsoleError(msg);
          if (statusEl) {
            statusEl.textContent = msg;
            statusEl.className = "small-note danger";
          }
          return;
        }

        const data = await res.json();
        let rawText = "";
        if (
          data.output &&
          data.output[0] &&
          data.output[0].content &&
          data.output[0].content[0] &&
          data.output[0].content[0].text
        ) {
          rawText = data.output[0].content[0].text;
        } else {
          throw new Error("Unexpected AI Debugger response shape.");
        }

        let parsed;
        try {
          parsed = JSON.parse(rawText);
        } catch (e) {
          appendConsoleError("AI Debugger JSON parse failed: " + String(e));
          if (statusEl) {
            statusEl.textContent = "AI Debugger returned non-JSON output.";
            statusEl.className = "small-note danger";
          }
          if (explanationEl) {
            explanationEl.textContent = "Raw AI output:\n" + rawText;
          }
          return;
        }

        const mode = parsed.mode || "";
        const issuesSummary = parsed.issuesSummary || "";
        const details = Array.isArray(parsed.details) ? parsed.details : [];
        const newIndexHtml = parsed.newIndexHtml || "";
        const externalHelpPrompt = parsed.externalHelpPrompt || "";

        let explanationLines = [];
        if (issuesSummary) {
          explanationLines.push("Summary: " + issuesSummary);
        }
        if (details.length) {
          explanationLines.push("");
          explanationLines.push("Details:");
          details.forEach((d, idx) => {
            explanationLines.push(
              "- [" + (idx+1) + "] Issue: " + (d.issue || "") +
              "\n    Likely cause: " + (d.likelyCause || "") +
              "\n    Fix: " + (d.fix || "") +
              "\n    Area: " + (d.changedArea || "")
            );
          });
        }
        if (explanationEl) {
          explanationEl.textContent = explanationLines.join("\n");
        }

        if (mode === "replacement_index" && newIndexHtml) {
          if (replacementEl) {
            replacementEl.value = newIndexHtml;
          }
          if (statusEl) {
            statusEl.textContent = "AI Debugger produced a replacement index.html. Review and paste into your editor if you are happy.";
            statusEl.className = "small-note";
          }
        } else if (mode === "external_help" && externalHelpPrompt) {
          if (replacementEl) {
            replacementEl.value = externalHelpPrompt;
          }
          if (statusEl) {
            statusEl.textContent = "AI Debugger suggests further investigation outside this file. Copy the text above into ChatGPT.";
            statusEl.className = "small-note";
          }
        } else {
          if (statusEl) {
            statusEl.textContent = "AI Debugger response did not include a valid mode/newIndexHtml or externalHelpPrompt.";
            statusEl.className = "small-note danger";
          }
        }
      } catch (e) {
        appendConsoleError("AI Debugger exception: " + String(e));
        if (statusEl) {
          statusEl.textContent = "AI Debugger failed: " + (e.message || String(e));
          statusEl.className = "small-note danger";
        }
      }
    }

    // =========
    // INIT
    // =========
    window.addEventListener("DOMContentLoaded", () => {
      logDebug("DOM loaded.");

      document.getElementById("signinBtn").addEventListener("click", signInManual);
      document.getElementById("processBtn").addEventListener("click", handleProcessMeeting);
      document.getElementById("generateProductsBtn").addEventListener("click", handleGenerateProducts);
      document.getElementById("downloadFilledTemplateBtn").addEventListener("click", handleDownloadFilledTemplate);
      document.getElementById("generateProposalBtn").addEventListener("click", handleGenerateProposal);
      document.getElementById("downloadProposalDocBtn").addEventListener("click", handleDownloadProposalDoc);

      const eventSelect = document.getElementById("eventSelect");
      eventSelect.addEventListener("change", () => {
        const idx = eventSelect.value;
        if (!idx) return;
        const ev = currentEvents[Number(idx)];
        if (ev) {
          setStatus("Selected: " + (ev.summary || "(no title)"), false);
        }
      });

      // API key handlers
      document.getElementById("saveApiKeyBtn").addEventListener("click", handleSaveApiKey);
      document.getElementById("clearApiKeyBtn").addEventListener("click", handleClearApiKey);
      refreshApiKeyStatus();

      // AI Debugger button
      const runAiDebugBtn = document.getElementById("runAiDebugBtn");
      if (runAiDebugBtn) {
        runAiDebugBtn.addEventListener("click", handleRunAiDebug);
      }

      setStatus("Waiting for sign-in…", false);

      // Prepare Google auth client
      setTimeout(() => {
        try { initAuth(); } catch(e) { logDebug("initAuth error: " + e.message); }
      }, 0);
    });
  </script>
</body>
</html>
